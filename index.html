<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>arthinking | ChinSyun Pang&#39;s blog</title>
  <meta name="author" content="arthinking">
  
  <meta name="description" content="Struggle for HighPay zoom.">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:site_name" content="arthinking"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="arthinking" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">arthinking</a>
  </h1>
  <p class="site-description">ChinSyun Pang&#39;s blog</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        
  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/02/高薪园博客系统搭建说明/"><span>高薪园博客系统搭建说明</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/02/高薪园博客系统搭建说明/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-02T09:04:25.000Z">
          2016-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: </p>
</blockquote>
<p>高薪园博客托管于Github,基于Hexo制作成静态博客;</p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>是一款基于Node.js的静态博客框架,简单的说,就是可以通过Hexo,把markdown文件直接转换成一个静态的网站输出到一个文件夹,然这个文件夹可以直接上传到服务器或者github,就可以访问啦~</p>
<h3 id="接下来是使用Hexo的使用方法"><a href="#接下来是使用Hexo的使用方法" class="headerlink" title="接下来是使用Hexo的使用方法:"></a>接下来是使用Hexo的使用方法:</h3><p>Hexo基于Node.js,所以需要先安装NodeJS的环境,怎么安装就不说啦,搜索一下可以找到相应的教程;主要通过NodeJS生成静态站点;</p>
<p>同时你需要安装Git,用于把代码提交到github上面去;</p>
<p>安装Hexo:</p>
<blockquote>
<p>sudo npm install-g hexo</p>
</blockquote>
<p>初始化项目:</p>
<blockquote>
<p>hexo init</p>
</blockquote>
<p>生成静态页面:</p>
<blockquote>
<p>hexo generate</p>
</blockquote>
<p>本地启动访问静态网站:</p>
<blockquote>
<p>hexo server</p>
</blockquote>
<p>启动之后会提示本地访问的地址,直接输入地址访问就可以啦;</p>
<p>接下来是把静态网站发布到github上面去,怎么使用github创建主页就不多说了,搜一下<code>github搭建博客</code>即可找到答案.</p>
<p>执行完<code>hexo init</code>之后,会在目录下面生成hexo相关的文件,其中<code>_config.yml</code>是hexo的配置文件,用于配置站点信息和发布信息的,我们编辑这个文件,在最后加上:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"></span><br><span class="line">     <span class="built_in">type</span>: git</span><br><span class="line"></span><br><span class="line">     repo:https://github.com/您的github项目仓库地址</span><br><span class="line"></span><br><span class="line">     branch:master</span><br></pre></td></tr></table></figure>
<p>注意,我们这里的<code>branch</code>需要设置为master,否则,css,js,图片等资源文件加载不到.</p>
<p>好的,为了通过hexo直接把项目直接发布到github仓库的master分支,需要再安装一个模块:</p>
<blockquote>
<p>npm install hexo-deployer-git–save</p>
</blockquote>
<p>执行如下命令,静态站点就push到github上面去啦:</p>
<blockquote>
<p>hexo deploy</p>
</blockquote>
<p>这个命令实际上是把我们刚才执行<code>hexo generate</code>所生成的<code>public</code>文件夹里面的所有内容,既是静态站点,push到了github的master分支上面;</p>
<p>每次部署的步骤,可以按照这样来:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>如果需要给博文添加标签或者分类,可以直接在markdown文件顶部这样设置:</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 高薪园博客系统搭建说明</span><br><span class="line">categories: [杂谈]</span><br><span class="line"><span class="section">tags: [Hexo]</span><br><span class="line">---</span></span><br></pre></td></tr></table></figure>
<p>其中title是博文的标题,categories是分类,tags是标签,如果有多个标签或者分类,按照这个格式进行添加:[a,b,c]</p>
<h2 id="Hexo相关的问题"><a href="#Hexo相关的问题" class="headerlink" title="Hexo相关的问题"></a>Hexo相关的问题</h2><p>文档中的分隔项不可以使用<code>---</code>，与hexo的文件顶部定义的字符冲突了，报如下错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAMLException: end of the stream or a document separator is expected at</span><br></pre></td></tr></table></figure>
<p>您应该尝试使用<code>***</code>替代。</p>
<p>以上就是我们搭建过程啦, Bon Voyage!</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://hexo.io/" target="_blank" rel="external">Hexo官网</a></li>
<li><a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="external">HEXO+Github,搭建属于自己的博客</a></li>
<li><a href="http://www.jianshu.com/collection/7fafdc0abb5b" target="_blank" rel="external">Hexo@简书</a></li>
<li><a href="http://ijiaober.github.io/categories/hexo/" target="_blank" rel="external">Hexo使用攻略</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/杂谈/">杂谈</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/Hexo/">Hexo</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/02/web前端项目搭建说明/"><span>web前端项目搭建说明</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/02/web前端项目搭建说明/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-02T09:03:39.000Z">
          2016-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com/web-project-setup-introduction-html.html" target="_blank" rel="external">web前端项目搭建说明</a><br>项目地址：<a href="https://github.com/highpay-zoom/app-mis" target="_blank" rel="external">app-mis</a></p>
</blockquote>
<h2 id="安装webpack："><a href="#安装webpack：" class="headerlink" title="安装webpack："></a>安装webpack：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack -g</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于<a href="https://docs.npmjs.com/" target="_blank" rel="external">npm install</a></p>
</blockquote>
<h3 id="初始化项目："><a href="#初始化项目：" class="headerlink" title="初始化项目："></a>初始化项目：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></table></figure>
<p>执行完这步会在目录下生成<code>package.json</code>文件</p>
<h3 id="为项目安装webpack："><a href="#为项目安装webpack：" class="headerlink" title="为项目安装webpack："></a>为项目安装webpack：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack --save-dev</span><br></pre></td></tr></table></figure>
<p>或者安装特定的版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack@1.2.x --save-dev</span><br></pre></td></tr></table></figure>
<p><a href="https://webpack.github.io/" target="_blank" rel="external">webpack</a>是一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。</p>
<p><strong>–save-dev 与 –save的区别</strong></p>
<blockquote>
<p>–save-dev: Package will appear in your devDependencies.<br>see<a href="http://stackoverflow.com/questions/19223051/grunt-js-what-does-save-dev-mean-in-npm-install-grunt-save-dev" target="_blank" rel="external">Grunt.js: What does -save-dev mean in npm install grunt –save-dev</a></p>
</blockquote>
<h3 id="安装webpack调试工具："><a href="#安装webpack调试工具：" class="headerlink" title="安装webpack调试工具："></a>安装webpack调试工具：</h3><blockquote>
<p>$ npm install webpack-dev-server –save-dev</p>
</blockquote>
<h4 id="启动webpack-dev-server："><a href="#启动webpack-dev-server：" class="headerlink" title="启动webpack-dev-server："></a>启动webpack-dev-server：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ webpack-dev-server --inline --hot</span><br></pre></td></tr></table></figure>
<p><a href="https://webpack.github.io/docs/webpack-dev-server.html" target="_blank" rel="external">webpack-dev-server</a>webpack-dev-server是一个小型的node.js Express服务器,它使用webpack-dev-middleware中间件来为通过webpack打包生成的资源文件提供Web服务。它还有一个通过Socket.IO连接着webpack-dev-server服务器的小型运行时程序。webpack-dev-server发送关于编译状态的消息到客户端，客户端根据消息作出响应。</p>
<h3 id="webpack构建命令："><a href="#webpack构建命令：" class="headerlink" title="webpack构建命令："></a>webpack构建命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ webpack --display-modules</span><br><span class="line">$ webpack --display-modules --display-chunks</span><br></pre></td></tr></table></figure>
<p><strong>–display-modules 和 –display-chunks的作用</strong></p>
<p>by default Webpack hides modules that are not yours. To see all the modules compiled by Webpack, we can pass the –display-modules flag.</p>
<p>run webpack with the –display-chunks flag to see what modules are in which chunks.</p>
<h2 id="安装需要的模块："><a href="#安装需要的模块：" class="headerlink" title="安装需要的模块："></a>安装需要的模块：</h2><h3 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save lodash</span><br></pre></td></tr></table></figure>
<p><a href="https://lodash.com/" target="_blank" rel="external">lodash</a>是一个Javascript工具库。</p>
<h3 id="安装babel："><a href="#安装babel：" class="headerlink" title="安装babel："></a>安装babel：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install babel-core babel-loader babel-preset-es2015 babel-preset-react babel-preset-stage-2 --save-dev</span><br></pre></td></tr></table></figure>
<p>然后在文件目录下创建 <code>.babelrc</code> 文件。详细配置参考：<a href="https://babeljs.io/" target="_blank" rel="external">babel</a></p>
<ul>
<li><a href="https://babeljs.io/" target="_blank" rel="external">babel</a>是一个Javascript代码转换器，可以把你写的符合 ECMAScript 6 标准的代码完美地转换为 ECMAScript 5 标准的代码，并且可以确保良好地运行在所有主流 JavaScript 引擎中。</li>
</ul>
<h3 id="安装eslint："><a href="#安装eslint：" class="headerlink" title="安装eslint："></a>安装eslint：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install eslint eslint-loader babel-eslint eslint-plugin-react --save-dev</span><br></pre></td></tr></table></figure>
<p>在团队协作中，为避免低级 Bug、产出风格统一的代码，会预先制定编码规范。使用 Lint 工具和代码风格检测工具，则可以辅助编码规范执行，有效控制代码质量。在以前的项目中，我们选择 JSHint 和 JSCS 结合使用，使用 React JSX 语法时，却遇到了问题：JSHint 不支持 JSX 语法，以有了 ESLint。<br><a href="http://eslint.org/" target="_blank" rel="external">eslint</a></p>
<h3 id="安装react："><a href="#安装react：" class="headerlink" title="安装react："></a>安装react：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react react-dom react-router --save</span><br></pre></td></tr></table></figure>
<h3 id="安装antd"><a href="#安装antd" class="headerlink" title="安装antd"></a>安装antd</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install antd --save</span><br></pre></td></tr></table></figure>
<h2 id="安装需要的webpack-loader："><a href="#安装需要的webpack-loader：" class="headerlink" title="安装需要的webpack loader："></a>安装需要的webpack loader：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install css-loader postcss-loader less-loader style-loader html-loader sass-loader node-sass --save-dev</span><br><span class="line">$ npm install url-loader file-loader --save-dev</span><br><span class="line">$ npm install baggage-loader --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="loader配置说明："><a href="#loader配置说明：" class="headerlink" title="loader配置说明："></a>loader配置说明：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"./loader!./dir/file.txt"</span>);</span><br><span class="line"><span class="comment">// =&gt; uses the file "loader.js" in the current directory to transform</span></span><br><span class="line"><span class="comment">//    "file.txt" in the folder "dir".</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"jade!./template.jade"</span>);</span><br><span class="line"><span class="comment">// =&gt; uses the "jade-loader" (that is installed from npm to "node_modules")</span></span><br><span class="line"><span class="comment">//    to transform the file "template.jade"</span></span><br><span class="line"><span class="comment">//    If configuration has some transforms bound to the file, they will still be applied.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"!style!css!less!bootstrap/less/bootstrap.less"</span>);</span><br><span class="line"><span class="comment">// =&gt; the file "bootstrap.less" in the folder "less" in the "bootstrap"</span></span><br><span class="line"><span class="comment">//    module (that is installed from github to "node_modules") is</span></span><br><span class="line"><span class="comment">//    transformed by the "less-loader". The result is transformed by the</span></span><br><span class="line"><span class="comment">//    "css-loader" and then by the "style-loader".</span></span><br><span class="line"><span class="comment">//    If configuration has some transforms bound to the file, they will not be applied.</span></span><br></pre></td></tr></table></figure>
<h2 id="安装需要的webpack-plugin："><a href="#安装需要的webpack-plugin：" class="headerlink" title="安装需要的webpack plugin："></a>安装需要的webpack plugin：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install clean-webpack-plugin --save-dev</span><br><span class="line">$ npm install extract-text-webpack-plugin --save-dev</span><br><span class="line">$ npm install html-webpack-plugin</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/johnagan/clean-webpack-plugin" target="_blank" rel="external">clean-webpack-plugin</a>: A webpack plugin to remove/clean your build folder(s) before building.</li>
<li><a href="https://github.com/webpack/extract-text-webpack-plugin" target="_blank" rel="external">extract-text-webpack-plugin</a>: It moves every require(“style.css”) in entry chunks into a separate css output file. So your styles are no longer inlined into the javascript, but separate in a css bundle file (styles.css).</li>
<li><a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="external">html-webpack-plugin</a>: Simplifies creation of HTML files to serve your webpack bundles</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="http://www.cnblogs.com/vajoy/p/4650467.html" target="_blank" rel="external">webpack 入门指南</a></li>
<li><a href="https://webpack.github.io/docs/webpack-dev-server.html" target="_blank" rel="external">webpack-dev-server</a></li>
<li><a href="http://www.jianshu.com/p/8adf4c2bfa51" target="_blank" rel="external">Webpack-dev-server结合后端分缶的热替换配置</a></li>
<li><a href="http://www.jianshu.com/p/941bfaf13be1" target="_blank" rel="external">WEBPACK DEV SERVER</a></li>
<li><a href="http://blog.madewithlove.be/post/webpack-your-bags/" target="_blank" rel="external">webpack your bags</a></li>
<li><a href="https://lodash.com/" target="_blank" rel="external">lodash</a></li>
<li><a href="https://babeljs.io/" target="_blank" rel="external">babel</a></li>
<li><a href="http://www.cnblogs.com/whitewolf/p/4357916.html" target="_blank" rel="external">Babel-现在开始使用 ES6</a></li>
<li><a href="http://eslint.org/" target="_blank" rel="external">eslint</a></li>
<li><a href="http://www.tuicool.com/articles/7JZZJzn" target="_blank" rel="external">ESLint 使用入门</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/web前端/">web前端</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/ReactJS/">ReactJS</a>, <a href="/tags/Webpack/">Webpack</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/cache/redis/2016-04-19 Redis相关命令/"><span>Redis相关命令</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/cache/redis/2016-04-19 Redis相关命令/" rel="bookmark">
        <time class="entry-date published" datetime="2016-04-19T00:59:06.000Z">
          2016-04-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: </p>
<ol>
<li><p><code>SETNX key value (SET if Not eXists)</code>:当且仅当 key 不存在，将 key 的值设为 value ，并返回1；若给定的 key 已经存在，则 SETNX 不做任何动作，并返回0。</p>
</li>
<li><p><code>GETSET key value</code>:将给定 key 的值设为 value ，并返回 key 的旧值 (old value)，当 key 存在但不是字符串类型时，返回一个错误，当key不存在时，返回nil。</p>
</li>
<li><p><code>GET key</code>:返回 key 所关联的字符串值，如果 key 不存在那么返回 nil 。</p>
</li>
<li><p><code>DEL key [KEY …]</code>:删除给定的一个或多个 key ,不存在的 key 会被忽略,返回实际删除的key的个数（integer）。</p>
</li>
<li><p><code>HSET key field value</code>：给一个key 设置一个{field=value}的组合值，如果key没有就直接赋值并返回1，如果field已有，那么就更新value的值，并返回0.</p>
</li>
<li><p><code>HEXISTS key field</code>:当key 中存储着field的时候返回1，如果key或者field至少有一个不存在返回0。</p>
</li>
<li><p><code>HINCRBY key field increment</code>:将存储在 key 中的哈希（Hash）对象中的指定字段 field 的值加上增量 increment。如果键 key 不存在，一个保存了哈希对象的新建将被创建。如果字段 field 不存在，在进行当前操作前，其将被创建，且对应的值被置为 0。返回值是增量之后的值。</p>
</li>
<li><p><code>PEXPIRE key milliseconds</code>：设置存活时间，单位是毫秒。expire操作单位是秒。</p>
</li>
</ol>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/Cache/">Cache</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/Redis/">Redis</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/javascript/reactjs/2016-04-04 需要了解的概念/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/javascript/reactjs/2016-04-04 需要了解的概念/" rel="bookmark">
        <time class="entry-date published" datetime="2016-04-04T04:49:57.000Z">
          2016-04-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h2><p><a href="http://www.cnblogs.com/haogj/p/5160821.html" target="_blank" rel="external">http://www.cnblogs.com/haogj/p/5160821.html</a></p>
<h2 id="ES6-module-default"><a href="#ES6-module-default" class="headerlink" title="ES6  module  default"></a>ES6  module  default</h2><h2 id="EJS"><a href="#EJS" class="headerlink" title="EJS"></a>EJS</h2><h2 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h2><h2 id="ReactJS的PropTypes-defaultProps"><a href="#ReactJS的PropTypes-defaultProps" class="headerlink" title="ReactJS的PropTypes  defaultProps"></a>ReactJS的PropTypes  defaultProps</h2><p><a href="http://facebook.github.io/react/docs/reusable-components.html" target="_blank" rel="external">http://facebook.github.io/react/docs/reusable-components.html</a></p>
<h2 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h2><p><a href="https://github.com/reactjs/react-router/tree/master/docs" target="_blank" rel="external">https://github.com/reactjs/react-router/tree/master/docs</a></p>
<h2 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h2>
      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/03/20/生活规律调整/"><span>产品销售市场的各个阶段</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/03/20/生活规律调整/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-20T13:47:29.000Z">
          2016-03-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: </p>
</blockquote>
<h1 id="节奏调整计划"><a href="#节奏调整计划" class="headerlink" title="节奏调整计划"></a>节奏调整计划</h1><p>晚上加班不超过9点，下班前记录工作总结和明日代办；</p>
<p>冲凉前<code>7分钟</code>健身运动；</p>
<p><code>10:30</code> 躺下准备睡觉，阅读书籍；</p>
<p><code>08:00</code> 闹铃，尽量提前，早睡，是为了睡到自然醒；</p>
<p>起床后舒缓下，<code>7分钟</code>健身运动；</p>
<p>边吃早餐边思考<code>计划</code>，然后开始进入工作状态，其他时间根据这个计划多思考；</p>
<p>到了上班时间开始编写<code>工作计划</code>，调好番茄闹钟；</p>
<p>少点打扰，多点<code>专注</code>。</p>
<h1 id="方向梳理"><a href="#方向梳理" class="headerlink" title="方向梳理"></a>方向梳理</h1><p><code>web移动客户端</code>技术试验，运用到工作和实际项目中；</p>
<p>后端技术，多尝试各种框架，跳出工作使用到的技术，<code>横向对比，纵向思考</code>，积累更多的技术选型和技术深度的思考。</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/杂谈/">杂谈</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/javascript/reactjs/2016-03-20 Redux/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/javascript/reactjs/2016-03-20 Redux/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-20T09:54:18.000Z">
          2016-03-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p><a href="http://camsong.github.io/redux-in-chinese/" target="_blank" rel="external">http://camsong.github.io/redux-in-chinese/</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/javascript/reactjs/2016-03-20 FLUX/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/javascript/reactjs/2016-03-20 FLUX/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-20T09:10:41.000Z">
          2016-03-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Flux概述"><a href="#Flux概述" class="headerlink" title="Flux概述"></a>Flux概述</h1><p>Flux是Facebook用来构建用户端的web应用的应用程序体系架构。它通过利用数据的单向流动为React的可复用的视图组件提供了补充。相比于形式化的框架它更像是一个架构思想，不需要太多新的代码你就可以马上使用Flux构建你的应用。</p>
<p>Flux应用主要包括三部分：dispatcher、store和views（React components），千万不要和MVC(model-View-Controller)搞混。Controller在Flux应用中也确实存在，但是是以controller-view的形式。view通常处于应用的顶层，它从stores中获取数据，同时将这些数据传递给它的后代节点。另外，action creators - dispatcher辅助方法 - 一个被用来提供描述应用所有可能存在的改变的语义化的API。把它理解为Flux更新闭环的第四个组成部分可以帮助你更好的理解它。</p>
<p>Flux使用单向的数据流动来避开MVC. 当用户与React视图交互的时候，视图会通过中枢dispatcher产生一个action。然后大量的保存着应用数据和业务逻辑的视图接收到冒泡的action，更新所有受影响的view。这种方式很适合React这种声明式的编程方式，因为它的store更新，并不需要特别指定如何在view和state中过渡。</p>
<p>我们独创性的解决了数据的获取：举个栗子，比如我们需要展示一个会话列表，高亮其中未读的会话，同时展示未读会话的数量。如果用MVC架构的话将很难处理这种情况，因为更新一个对话为已读的时候会更新对话model，然后同样也需要更新未读对话数量model（数量-1）。这样的依赖和瀑布式的更新在大型的应用中非常常见，导致错综复杂的数据流动和不可预测的结果。（这其实是Facebook之前的一个线上bug，有时候用户看到提示说有一条未读信息，但是点进去却发现没有）。</p>
<p>反过来让 Store 来控制：store接受更新，并在合适的时机处理这些更新。而不是采用一贯依赖外部的方式来更新数据。在store外部，并没办法看到store内部是如何处理它内部的数据的，这样的方式保证了一个清晰的关注点分离。Store并没有类似setAsRead()这样直接的setter方法，但是在其自成一体的世界中拥有唯一个获取新数据的方法 - store通过dispatcher注册的回调函数。</p>
<h2 id="Structure-and-Data-Flow"><a href="#Structure-and-Data-Flow" class="headerlink" title="Structure and Data Flow"></a>Structure and Data Flow</h2><p>Flux中数据是单项流动的：</p>
<p><img src="media/14584657887641.jpg" alt=""></p>
<p>用户的交互可能会使views产生新的action。</p>
<h2 id="A-Single-Dispatcher"><a href="#A-Single-Dispatcher" class="headerlink" title="A Single Dispatcher"></a>A Single Dispatcher</h2><p>dispatcher 就像是一个中央的集线器，管理着所有的数据流。本质上它就是 store callback 的注册表，本身并没有实际的高度功能。它就是一个用来向stores分发actions的机器。 每一个 store 各自注册自己的 callback 以提供对应的处理动作。当 dispatcher 发出一个 action 时，应用中所有的store都会通过注册的callback收到这个action。</p>
<h2 id="Stores"><a href="#Stores" class="headerlink" title="Stores"></a>Stores</h2><p>Stores 包含了应用的状态和逻辑。</p>
<p>store在dispatcher中注册，并提供相应的回调。</p>
<p>store更新完成之后，会向应用中广播一个change事件，views可以选择响应事件来重新获取新的数据并更新。</p>
<h2 id="Views-and-Controller-Views"><a href="#Views-and-Controller-Views" class="headerlink" title="Views and Controller-Views"></a>Views and Controller-Views</h2><p>React提供了一种可组合式的view让我们可以自由组合展示层。在接近顶层的地方，有些view需要监听所依赖的store的广播事件。我们称之为controller-view，因为他们提供了胶水代码来从store中获取数据，并向下层层传递这些数据。我们会利用这些controller-views来处理页面上某些重要部分。</p>
<h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>dispatcher提供了一个可以允许我们向store中触发分发的方法，我们称之为action。</p>
<h2 id="What-About-that-Dispatcher"><a href="#What-About-that-Dispatcher" class="headerlink" title="What About that Dispatcher?"></a>What About that Dispatcher?</h2><p>dispatcher也可以用来管理store之间的依赖。</p>
<h1 id="Flux-TodoMVC-Tutorial"><a href="#Flux-TodoMVC-Tutorial" class="headerlink" title="Flux TodoMVC Tutorial"></a>Flux TodoMVC Tutorial</h1>
      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/javascript/reactjs/2016-03-20 参考/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/javascript/reactjs/2016-03-20 参考/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-20T07:07:56.000Z">
          2016-03-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="1、顶层API"><a href="#1、顶层API" class="headerlink" title="1、顶层API"></a>1、顶层API</h1><h2 id="1-1、React"><a href="#1-1、React" class="headerlink" title="1.1、React"></a>1.1、React</h2><p>React 是 React 库的入口。如果使用的是预编译包，则 React 是全局的；如果使用 CommonJS 模块系统，则可以用 require() 函数引入 React。</p>
<h3 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass"></a>React.createClass</h3><p>创建一个组件类，并作出定义。组件实现了 render() 方法，该方法返回一个子级。该子级可能包含很深的子级结构。</p>
<h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h3><p>创建并返回一个新的指定类型的 ReactElement。</p>
<h3 id="React-createFactory"><a href="#React-createFactory" class="headerlink" title="React.createFactory"></a>React.createFactory</h3><p>返回一个生成指定类型 ReactElements 的函数。</p>
<h3 id="React-render"><a href="#React-render" class="headerlink" title="React.render"></a>React.render</h3><p>渲染一个 ReactElement 到 DOM 中。</p>
<h3 id="React-unmountComponentAtNode"><a href="#React-unmountComponentAtNode" class="headerlink" title="React.unmountComponentAtNode"></a>React.unmountComponentAtNode</h3><p>从 DOM 中移除已经挂载的 React 组件，清除相应的事件处理器和 state。</p>
<h3 id="React-renderToString"><a href="#React-renderToString" class="headerlink" title="React.renderToString"></a>React.renderToString</h3><p>把组件渲染成原始的 HTML 字符串。该方法应该仅在服务器端使用。</p>
<h3 id="React-renderToStaticMarkup"><a href="#React-renderToStaticMarkup" class="headerlink" title="React.renderToStaticMarkup"></a>React.renderToStaticMarkup</h3><p>和 renderToString 类似，除了不创建额外的 DOM 属性，例如 data-react-id，因为这些属性仅在 React 内部使用。如果你想用 React 做一个简单的静态页面生成器，这是很有用的，因为丢掉额外的属性能够节省很多字节。</p>
<h3 id="React-isValidElement"><a href="#React-isValidElement" class="headerlink" title="React.isValidElement"></a>React.isValidElement</h3><p>判断对象是否是一个 ReactElement。</p>
<h3 id="React-DOM"><a href="#React-DOM" class="headerlink" title="React.DOM"></a>React.DOM</h3><p>React.DOM 运用 React.createElement 为 DOM 组件提供了方便的包装。该方式仅在未使用 JSX 的时候适用。例如，React.DOM.div(null, ‘Hello World!’)。</p>
<h3 id="React-PropTypes"><a href="#React-PropTypes" class="headerlink" title="React.PropTypes"></a>React.PropTypes</h3><p>React.PropTypes 包含了能与组件 propTypes 对象共用的类型，用于验证传入组件的 props。</p>
<h3 id="React-initializeTouchEvents"><a href="#React-initializeTouchEvents" class="headerlink" title="React.initializeTouchEvents"></a>React.initializeTouchEvents</h3><p>配置 React 的事件系统，使 React 能处理移动设备的触摸（ touch ）事件。</p>
<h3 id="React-Children"><a href="#React-Children" class="headerlink" title="React.Children"></a>React.Children</h3><p>React.Children 为处理 this.props.children 这个封闭的数据结构提供了有用的工具。</p>
<h4 id="React-Children-map"><a href="#React-Children-map" class="headerlink" title="React.Children.map"></a>React.Children.map</h4><p>在每一个直接子级（包含在 children 参数中的）上调用 fn 函数，此函数中的 this 指向 上下文。如果 children 是一个内嵌的对象或者数组，它将被遍历：不会传入容器对象到 fn 中。</p>
<h4 id="React-Children-forEach"><a href="#React-Children-forEach" class="headerlink" title="React.Children.forEach"></a>React.Children.forEach</h4><p>类似于 React.Children.map()，但是不返回对象。</p>
<h4 id="React-Children-count"><a href="#React-Children-count" class="headerlink" title="React.Children.count"></a>React.Children.count</h4><p>返回 children 当中的组件总数，和传递给 map 或者 forEach 的回调函数的调用次数一致。</p>
<h4 id="React-Children-only"><a href="#React-Children-only" class="headerlink" title="React.Children.only"></a>React.Children.only</h4><p>返回 children 中仅有的子级。否则抛出异常。</p>
<h1 id="2、组件API"><a href="#2、组件API" class="headerlink" title="2、组件API"></a>2、组件API</h1><p>ReactComponent。唯一一种在 React 之外获取 React 组件实例句柄的方式就是保存 React.render 的返回值。在其它组件内，可以使用 refs 得到相同的结果。</p>
<h2 id="2-1、setState"><a href="#2-1、setState" class="headerlink" title="2.1、setState"></a>2.1、setState</h2><p>合并 nextState 和当前 state。这是在事件处理函数中和请求回调函数中触发 UI 更新的主要方法。</p>
<blockquote>
<p>绝对不要直接改变 this.state；<br>setState() 不会立刻改变 this.state，而是创建一个即将处理的 state 转变；<br>不保证 setState() 调用的同步性；<br>setState() 将总是触发一次重绘，除非在 shouldComponentUpdate() 中实现了条件渲染逻辑。</p>
</blockquote>
<h2 id="2-2、replaceState"><a href="#2-2、replaceState" class="headerlink" title="2.2、replaceState"></a>2.2、replaceState</h2><p>类似于 setState()，但是删除之前所有已存在的 state 键，这些键都不在 nextState 中。</p>
<h2 id="2-3、forceUpdate"><a href="#2-3、forceUpdate" class="headerlink" title="2.3、forceUpdate()"></a>2.3、forceUpdate()</h2><p>如果 render() 方法从 this.props 或者 this.state 之外的地方读取数据，你需要通过调用 forceUpdate() 告诉 React 什么时候需要再次运行 render()。如果直接改变了 this.state，也需要调用 forceUpdate()。</p>
<p>通常情况下，应该尽量避免所有使用forceUpdate()的情况。</p>
<h2 id="2-4、getDOMNode"><a href="#2-4、getDOMNode" class="headerlink" title="2.4、getDOMNode"></a>2.4、getDOMNode</h2><p>如果组件已经挂载到了 DOM 上，该方法返回相应的本地浏览器 DOM 元素。</p>
<h2 id="2-5、iSMounted"><a href="#2-5、iSMounted" class="headerlink" title="2.5、iSMounted()"></a>2.5、iSMounted()</h2><p>如果组件渲染到了 DOM 中，isMounted() 返回 true。</p>
<h2 id="2-6、setProps"><a href="#2-6、setProps" class="headerlink" title="2.6、setProps()"></a>2.6、setProps()</h2><p>可以调用 setProps() 来改变组件的属性，触发一次重新渲染。</p>
<blockquote>
<p>刚方法仅在根组件上面调用。也就是说，仅在直接传给 React.render() 的组件上可用，在它的子级组件上不可用。如果你倾向于在子组件上使用 setProps()，不要利用响应式更新，而是当子组件在 render() 中创建的时候传入新的 prop 到子组件中。</p>
</blockquote>
<h2 id="2-7、replaceProps"><a href="#2-7、replaceProps" class="headerlink" title="2.7、replaceProps"></a>2.7、replaceProps</h2><p>类似于 setProps()，但是删除所有已存在的 props，而不是合并新旧两个 props 对象。</p>
<h1 id="3、组件的详细说明和生命周期"><a href="#3、组件的详细说明和生命周期" class="headerlink" title="3、组件的详细说明和生命周期"></a>3、组件的详细说明和生命周期</h1><h2 id="3-1、组件的详细说明"><a href="#3-1、组件的详细说明" class="headerlink" title="3.1、组件的详细说明"></a>3.1、组件的详细说明</h2><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>当调用的时候，会检测 this.props 和 this.state，返回一个单子级组件。</p>
<p>render() 函数应该是纯粹的，也就是说该函数不修改组件 state，每次调用都返回相同的结果，不读写 DOM 信息，也不和浏览器交互（例如通过使用 setTimeout）。</p>
<h3 id="getInitialState"><a href="#getInitialState" class="headerlink" title="getInitialState"></a>getInitialState</h3><p>在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。</p>
<h3 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h3><p>在组件类创建的时候调用一次，然后返回值被缓存下来。如果父组件没有指定 props 中的某个键，则此处返回的对象中的相应属性将会合并到 this.props （使用 in 检测属性）。</p>
<h3 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h3><p>propTypes 对象允许验证传入到组件的 props。</p>
<h3 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h3><p>mixin 数组允许使用混合来在多个组件之间共享行为。</p>
<h3 id="statics"><a href="#statics" class="headerlink" title="statics"></a>statics</h3><p>statics 对象允许你定义静态的方法，这些静态的方法可以在组件类上调用。</p>
<h3 id="displayName"><a href="#displayName" class="headerlink" title="displayName"></a>displayName</h3><p>displayName 字符串用于输出调试信息。</p>
<h2 id="3-2、组件的生命周期"><a href="#3-2、组件的生命周期" class="headerlink" title="3.2、组件的生命周期"></a>3.2、组件的生命周期</h2><h3 id="挂载：componentWillMount"><a href="#挂载：componentWillMount" class="headerlink" title="挂载：componentWillMount"></a>挂载：componentWillMount</h3><p>服务器端和客户端都只调用一次，在初始化渲染执行之前立刻调用。如果在这个方法内调用 setState，render() 将会感知到更新后的 state，将会执行仅一次，尽管 state 改变了。</p>
<h3 id="挂载：componentDidMount"><a href="#挂载：componentDidMount" class="headerlink" title="挂载：componentDidMount"></a>挂载：componentDidMount</h3><p>在初始化渲染执行之后立刻调用一次，仅客户端有效（服务器端不会调用）。在生命周期中的这个时间点，组件拥有一个 DOM 展现，你可以通过 this.getDOMNode() 来获取相应 DOM 节点。</p>
<p>如果想和其它 JavaScript 框架集成，使用 setTimeout 或者 setInterval 来设置定时器，或者发送 AJAX 请求，可以在该方法中执行这些操作。</p>
<h3 id="更新：componentWillReceiveProps"><a href="#更新：componentWillReceiveProps" class="headerlink" title="更新：componentWillReceiveProps"></a>更新：componentWillReceiveProps</h3><p>在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。</p>
<p>用此函数可以作为 react 在 prop 传入之后， render() 渲染之前更新 state 的机会。老的 props 可以通过 this.props 获取到。在该函数中调用 this.setState() 将不会引起第二次渲染。</p>
<h3 id="更新：shouldComponentUpdate"><a href="#更新：shouldComponentUpdate" class="headerlink" title="更新：shouldComponentUpdate"></a>更新：shouldComponentUpdate</h3><p>在接收到新的 props 或者 state，将要渲染之前调用。该方法在初始化渲染的时候不会调用，在使用 forceUpdate 方法的时候也不会。</p>
<p>如果确定新的 props 和 state 不会导致组件更新，则此处应该 返回 false。</p>
<h3 id="更新：componentWillUpdate"><a href="#更新：componentWillUpdate" class="headerlink" title="更新：componentWillUpdate"></a>更新：componentWillUpdate</h3><p>在接收到新的 props 或者 state 之前立刻调用。在初始化渲染的时候该方法不会被调用。</p>
<p>使用该方法做一些更新之前的准备工作。</p>
<blockquote>
<p>你不能在刚方法中使用 this.setState()。如果需要更新 state 来响应某个 prop 的改变，请使用 componentWillReceiveProps。</p>
</blockquote>
<h3 id="更新：componentDidUpdate"><a href="#更新：componentDidUpdate" class="headerlink" title="更新：componentDidUpdate"></a>更新：componentDidUpdate</h3><p>在组件的更新已经同步到 DOM 中之后立刻被调用。该方法不会在初始化渲染的时候调用。</p>
<p>使用该方法可以在组件更新之后操作 DOM 元素。</p>
<h3 id="移除：componentWillUnmount"><a href="#移除：componentWillUnmount" class="headerlink" title="移除：componentWillUnmount"></a>移除：componentWillUnmount</h3><p>在组件从 DOM 中移除的时候立刻被调用。</p>
<p>在该方法中执行任何必要的清理，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素。</p>
<h1 id="3、标签和属性支持"><a href="#3、标签和属性支持" class="headerlink" title="3、标签和属性支持"></a>3、标签和属性支持</h1><h2 id="3-1、支持的标签"><a href="#3-1、支持的标签" class="headerlink" title="3.1、支持的标签"></a>3.1、支持的标签</h2><p>React 尝试支持所用常用的元素。如果你需要的元素没有在下面列出来，请提交一个问题（issue）。</p>
<h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><h3 id="SVG元素"><a href="#SVG元素" class="headerlink" title="SVG元素"></a>SVG元素</h3><h2 id="3-2、支持度-属性"><a href="#3-2、支持度-属性" class="headerlink" title="3.2、支持度 属性"></a>3.2、支持度 属性</h2><p>React 支持所有 data-<em> 和 aria-</em> 属性，也支持下面列出的属性。</p>
<blockquote>
<p>所有的属性都是驼峰命名的，class 属性和 for 属性分别改为 className 和 htmlFor，来符合 DOM API 规范。</p>
</blockquote>
<h3 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept acceptCharset accessKey action allowFullScreen allowTransparency altasync autoComplete autoPlay cellPadding cellSpacing charSet checked classIDclassName cols colSpan content contentEditable contextMenu controls coordscrossOrigin data dateTime defer dir disabled download draggable encType formformAction formEncType formMethod formNoValidate formTarget frameBorder heighthidden href hrefLang htmlFor httpEquiv icon id label lang list loop manifestmarginHeight marginWidth max maxLength media mediaGroup method min multiplemuted name noValidate open pattern placeholder poster preload radioGroupreadOnly rel required role rows rowSpan sandbox scope scrolling seamlessselected shape size sizes span spellCheck src srcDoc srcSet start step styletabIndex target title type useMap value width wmode</span><br></pre></td></tr></table></figure>
<h3 id="SVG属性"><a href="#SVG属性" class="headerlink" title="SVG属性"></a>SVG属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx cy d dx dy fill fillOpacity fontFamily fontSize fx fy gradientTransformgradientUnits markerEnd markerMid markerStart offset opacitypatternContentUnits patternUnits points preserveAspectRatio r rx ryspreadMethod stopColor stopOpacity stroke strokeDasharray strokeLinecapstrokeOpacity strokeWidth textAnchor transform version viewBox x1 x2 x y1 y2 y</span><br></pre></td></tr></table></figure>
<h1 id="4、事件系统"><a href="#4、事件系统" class="headerlink" title="4、事件系统"></a>4、事件系统</h1><h2 id="4-1、虚拟事件对象"><a href="#4-1、虚拟事件对象" class="headerlink" title="4.1、虚拟事件对象"></a>4.1、虚拟事件对象</h2><p>事件处理器将会传入虚拟事件对象的实例，一个对浏览器本地事件的跨浏览器封装。它有和浏览器本地事件相同的属性和方法，包括 stopPropagation() 和 preventDefault()，但是没有浏览器兼容问题。</p>
<p>如果因为一些因素，需要底层的浏览器事件对象，只要使用<code>nativeEvent</code>属性就可以获取到它了。每一个虚拟事件对象都有下列的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEvent<span class="keyword">void</span> preventDefault()<span class="keyword">void</span> stopPropagation()DOMEventTarget targetnumber timeStampstring type</span><br></pre></td></tr></table></figure>
<h2 id="4-2、支持的事件"><a href="#4-2、支持的事件" class="headerlink" title="4.2、支持的事件"></a>4.2、支持的事件</h2><p>React 标准化了事件对象，因此在不同的浏览器中都会有相同的属性。</p>
<p>如下的事件处理器在事件冒泡阶段触发。要在捕获阶段触发某个事件处理器，在事件名字后面追加 <code>Capture</code>字符串；例如，使用 onClickCapture </p>
<h3 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h3><blockquote>
<p>onCopy onCut onPaste</p>
</blockquote>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><blockquote>
<p>onKeyDown onKeyPress onKeyUp</p>
</blockquote>
<h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><blockquote>
<p>onFocus onBlur</p>
</blockquote>
<h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><blockquote>
<p>onChange onInput onSubmit</p>
</blockquote>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><blockquote>
<p>onClick onDoubleClick onDrag onDragEnd onDragEnter onDragExit onDragLeave<br>onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave<br>onMouseMove onMouseOut onMouseOver onMouseUp</p>
</blockquote>
<h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><blockquote>
<p>onTouchCancel onTouchEnd onTouchMove onTouchStart</p>
</blockquote>
<h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><blockquote>
<p>onScroll</p>
</blockquote>
<h3 id="鼠标滚轮滚动事件"><a href="#鼠标滚轮滚动事件" class="headerlink" title="鼠标滚轮滚动事件"></a>鼠标滚轮滚动事件</h3><blockquote>
<p>onWheel</p>
</blockquote>
<h1 id="5、与DOM的差异"><a href="#5、与DOM的差异" class="headerlink" title="5、与DOM的差异"></a>5、与DOM的差异</h1><p>React 为了性能和跨浏览器的原因，实现了一个独立于浏览器的事件和 DOM 系统。利用此功能，可以屏蔽掉一些浏览器的 DOM 的粗糙实现。</p>
<h1 id="6、特殊的非DOM属性"><a href="#6、特殊的非DOM属性" class="headerlink" title="6、特殊的非DOM属性"></a>6、特殊的非DOM属性</h1><p>除了与 DOM 的差异之外，React 也提供了一些 DOM 里面不存在的属性：</p>
<ul>
<li>key</li>
<li>ref</li>
<li>dangerouslySetInnerHTML</li>
</ul>
<h1 id="7、Reconciliation"><a href="#7、Reconciliation" class="headerlink" title="7、Reconciliation"></a>7、Reconciliation</h1><p>这篇文章解释了我们如何使用强大的试探法来将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题。</p>
<h2 id="7-1、动机"><a href="#7-1、动机" class="headerlink" title="7.1、动机"></a>7.1、动机</h2><p>生成最少的将一颗树形结构转换成另一颗树形结构的操作，是一个复杂的，并且值得研究的问题。最优算法的复杂度是 O(n3)，n 是树中节点的总数。</p>
<h2 id="7-2、两个节点的差异检查"><a href="#7-2、两个节点的差异检查" class="headerlink" title="7.2、两个节点的差异检查"></a>7.2、两个节点的差异检查</h2><h3 id="不同的节点类型"><a href="#不同的节点类型" class="headerlink" title="不同的节点类型"></a>不同的节点类型</h3><p>如果节点的类型不同，React 将会把它们当做两个不同的子树，移除之前的那棵子树，然后创建并插入第二棵子树。</p>
<h3 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h3><p>当比较两个 DOM 节点的时候，我们查看两者的属性，然后能够找出哪一个属性随着时间产生了变化。</p>
<h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><p>因为组件是状态化的，不可能每次状态改变都要创建一个新的组件实例。React 利用新组件上的所有属性，然后在之前的组件实例上调用 component[Will/Did]ReceiveProps()。</p>
<h2 id="7-2、子级优化差异算法（List-wise-diff）"><a href="#7-2、子级优化差异算法（List-wise-diff）" class="headerlink" title="7.2、子级优化差异算法（List-wise diff）"></a>7.2、子级优化差异算法（List-wise diff）</h2><h3 id="问题点（Problematic-Case）"><a href="#问题点（Problematic-Case）" class="headerlink" title="问题点（Problematic Case）"></a>问题点（Problematic Case）</h3><p>为了完成子级更新，React 选用了一种很原始的方法。React 同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。</p>
<h3 id="键（Keys）"><a href="#键（Keys）" class="headerlink" title="键（Keys）"></a>键（Keys）</h3><p>为了解决这个看起来很棘手的问题，引入了一个可选的属性。可以给每个子级一个键值，用于将来的匹配比较。如果指定了一个键值，React 就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为 O(n)。</p>
<h2 id="7-3、权衡（Trade-offs）"><a href="#7-3、权衡（Trade-offs）" class="headerlink" title="7.3、权衡（Trade-offs）"></a>7.3、权衡（Trade-offs）</h2><p>为了完成子级更新，React 选用了一种很原始的方法。React 同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。</p>
<h1 id="8、React（虚拟）DOM术语"><a href="#8、React（虚拟）DOM术语" class="headerlink" title="8、React（虚拟）DOM术语"></a>8、React（虚拟）DOM术语</h1><p>五个核心类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactElement / ReactElement 工厂</span><br><span class="line">ReactNode</span><br><span class="line">ReactComponent / ReactComponent 类</span><br></pre></td></tr></table></figure>
<h2 id="8-1、React元素"><a href="#8-1、React元素" class="headerlink" title="8.1、React元素"></a>8.1、React元素</h2><p>React 中最主要的类型就是 ReactElement。它有四个属性：type，props，key 和 ref。它没有方法，并且原型上什么都没有。</p>
<p>可以通过 React.createElement 创建该类型的一个实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> root = React.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure>
<p>要添加属性到 DOM 元素，把属性对象作为第二个参数传入 React.render，把子级作为第三个参数传给 React.render。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = React.createElement(<span class="string">'li'</span>, <span class="literal">null</span>, <span class="string">'Text Content'</span>);</span><br><span class="line"><span class="keyword">var</span> root = React.createElement(<span class="string">'ul'</span>, &#123; className: <span class="string">'my-list'</span> &#125;, child);</span><br><span class="line">React.render(root, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p>如果使用 React JSX 语法，这些 ReactElement 实例自动创建。</p>
<h3 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h3><p>一个 ReactElement 工厂就是一个简单的函数，该函数生成一个带有特殊 type 属性的 ReactElement:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFactory</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement.bind(<span class="literal">null</span>, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数能创建一个方便的短函数，而不是总调用 React.createElement(‘div’):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = React.createFactory(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> root = div(&#123; className: <span class="string">'my-div'</span> &#125;);</span><br><span class="line">React.render(root, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p>React 已经内置了常用 HTML 标签的工厂函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> root = React.DOM.ul(&#123; className: <span class="string">'my-list'</span> &#125;,</span><br><span class="line">             React.DOM.li(<span class="literal">null</span>, <span class="string">'Text Content'</span>)</span><br><span class="line">           );</span><br></pre></td></tr></table></figure>
<p>如果使用 JSX 语法，就不需要工厂函数了。JSX 已经提供了一种方便的短函数来创建 ReactElement 实例。</p>
<h2 id="8-2、React节点"><a href="#8-2、React节点" class="headerlink" title="8.2、React节点"></a>8.2、React节点</h2><p>一个 ReactNode 可以是：</p>
<ul>
<li>ReactElement</li>
<li>string （又名 ReactText）</li>
<li>number （又名 ReactText）</li>
<li>ReactNode 实例数组 （又名 ReactFragment）</li>
</ul>
<h2 id="8-3、React组件"><a href="#8-3、React组件" class="headerlink" title="8.3、React组件"></a>8.3、React组件</h2><p>在使用 React 开发中，可以仅使用 ReactElement 实例，但是，要充分利用 React，就要使用 ReactComponent 来封装状态化的组件。</p>
<p>一个 ReactComponent 类就是一个简单的 JavaScript 类（或者说是“构造函数”）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当该构造函数调用的时候，应该会返回一个对象，该对象至少带有一个 render 方法。该对象指向一个 ReactComponent 实例。</p>
<p>除非为了测试，正常情况下不要自己调用该构造函数。React 帮你调用这个函数。</p>
<p>把 ReactComponent 类传给 createElement，就会得到一个 ReactElement 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = React.createElement(MyComponent);</span><br></pre></td></tr></table></figure>
<p>或者使用 JSX：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>当该实例传给 React.render 的时候，React 将会调用构造函数，然后创建并返回一个 ReactComponent。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> component = React.render(element, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p>如果一直用相同的 ReactElement 类型和相同的 DOM 元素容器调用 React.render，将会总是返回相同的实例。该实例是状态化的。如果自己手动创建Componnet实力，则不会又这样的优化。</p>
<p>ReactComponent 的 render 方法应该返回另一个 ReactElement，这就允许组件被组装。</p>
<h2 id="8-4、正式的类型定义"><a href="#8-4、正式的类型定义" class="headerlink" title="8.4、正式的类型定义"></a>8.4、正式的类型定义</h2><h3 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h3><h3 id="节点和元素"><a href="#节点和元素" class="headerlink" title="节点和元素"></a>节点和元素</h3><h3 id="类和组件"><a href="#类和组件" class="headerlink" title="类和组件"></a>类和组件</h3>
      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/javascript/reactjs/2016-03-20 插件 React.addons/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/javascript/reactjs/2016-03-20 插件 React.addons/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-20T07:02:30.000Z">
          2016-03-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p><code>React.addons</code>是为了构建 React 应用而放置的一些有用工具的地方。此功能应当被视为实验性的，但最终将会被添加进核心代码中或者有用的工具库中：</p>
<ul>
<li><code>TransitionGroup</code>和<code>CSSTransitionGroup</code>，用于处理动画和过渡，这些通常实现起来都不简单，例如在一个组件移除之前执行一段动画。</li>
<li><code>LinkedStateMixin</code>，用于简化用户表单输入数据和组件 state 之间的双向数据绑定。</li>
<li><code>classSet</code>，用于更加干净简洁地操作 DOM 中的 class 字符串。</li>
<li><code>cloneWithProps</code>，用于实现 React 组件浅复制，同时改变它们的 props 。</li>
<li><code>update</code>，一个辅助方法，使得在 JavaScript 中处理不可变数据更加容易。</li>
<li><code>PureRenderMixin</code>，在某些场景下的性能检测器。</li>
</ul>
<p>以下插件只存在于 React 开发版（未压缩）：</p>
<ul>
<li><code>TestUtils</code>， 简单的辅助工具，用于编写测试用例（仅存在于未压缩版）.</li>
<li><code>Perf</code>，用于性能测评，并帮助你检查出可优化的功能点。</li>
</ul>
<p>要使用这些插件，需要用<code>react-with-addons.js</code>（和它的最小化副本）替换常规的React.js。</p>
<p>当通过npm使用react包的时候，只要简单地用<code>require(&#39;react/addons&#39;)</code>替换 require(‘react’) 来得到带有所有插件的React。</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/javascript/reactjs/2016-03-19 ReactJS入门/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/javascript/reactjs/2016-03-19 ReactJS入门/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-19T08:15:53.000Z">
          2016-03-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="1、数据呈现"><a href="#1、数据呈现" class="headerlink" title="1、数据呈现"></a>1、数据呈现</h1><h3 id="响应式更新（Reactive-Updates）"><a href="#响应式更新（Reactive-Updates）" class="headerlink" title="响应式更新（Reactive Updates）"></a>响应式更新（Reactive Updates）</h3><p><code>this.props</code>是只读的。</p>
<h3 id="组件就像是函数"><a href="#组件就像是函数" class="headerlink" title="组件就像是函数"></a>组件就像是函数</h3><p>React组件非常像函数，接收<code>props</code>和<code>status</code>作为参数，然后渲染出HTML。</p>
<h3 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h3><p>ReactJS中相信：标签与生成它的代码是紧密相连的，所以不做<code>模板引擎</code>和<code>展示逻辑</code>的分离。最好的方法是通过Javascript直接生成模板，为此JSX派上用场了：一个非常简单、可选类似 HTML 语法 ，通过函数调用即可生成模板的编译器。</p>
<blockquote>
<p>JSX 让你可以用 HTML 语法去写 JavaScript 函数调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(<span class="string">'a'</span>, &#123;href: <span class="string">'http://facebook.github.io/react/'</span>&#125;, <span class="string">'Hello React!'</span>)。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>JSX语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"http://facebook.github.io/react/"</span>&gt;Hello React!&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-1、深入理解JSX"><a href="#1-1、深入理解JSX" class="headerlink" title="1.1、深入理解JSX"></a>1.1、深入理解JSX</h2><p>JSX是一个看起来像XML的JavaScript语法扩展。React可以用来做简单的JSX句法转换。</p>
<h3 id="1-1-1、为什么要使用JSX"><a href="#1-1-1、为什么要使用JSX" class="headerlink" title="1.1.1、为什么要使用JSX"></a>1.1.1、为什么要使用JSX</h3><p>能够定义简洁且我们熟知的包含属性的树状结构语法。</p>
<h3 id="1-1-2、HTML标签与React组件对比"><a href="#1-1-2、HTML标签与React组件对比" class="headerlink" title="1.1.2、HTML标签与React组件对比"></a>1.1.2、HTML标签与React组件对比</h3><p>React 的 JSX 里约定分别使用首字母大、小写来区分本地组件的类和 HTML 标签。</p>
<h3 id="1-1-3、转换"><a href="#1-1-3、转换" class="headerlink" title="1.1.3、转换"></a>1.1.3、转换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> app = &lt;Nav color="blue" /&gt;;</span><br><span class="line">// 等价于</span><br><span class="line">var app = React.createElement(Nav, &#123;color:"blue"&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Nav, Profile;</span><br><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> app = &lt;Nav color="blue"&gt;&lt;Profile&gt;click&lt;/Profile&gt;&lt;/Nav&gt;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> app = React.createElement(</span><br><span class="line">  Nav,</span><br><span class="line">  &#123;color:<span class="string">"blue"</span>&#125;,</span><br><span class="line">  React.createElement(Profile, <span class="literal">null</span>, <span class="string">"click"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="1-1-4、JavaScript表达式"><a href="#1-1-4、JavaScript表达式" class="headerlink" title="1.1.4、JavaScript表达式"></a>1.1.4、JavaScript表达式</h3><h4 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h4><p>使用JavaScript表达式作为属性值，使用{}<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> person = &lt;Person name=&#123;window.isLoggedIn ? window.name : ''&#125; /&gt;;</span><br><span class="line">// 等价于</span><br><span class="line">var person = React.createElement(</span><br><span class="line">  Person,</span><br><span class="line">  &#123;name: window.isLoggedIn ? window.name : ''&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="子节点表达式"><a href="#子节点表达式" class="headerlink" title="子节点表达式"></a>子节点表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">var</span> content = &lt;Container&gt;&#123;window.isLoggedIn ? &lt;Nav /&gt; : &lt;Login /&gt;&#125;&lt;/Container&gt;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> content = React.createElement(</span><br><span class="line">  Container,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="built_in">window</span>.isLoggedIn ? React.createElement(Nav) : React.createElement(Login)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>JSX 里添加注释很容易；它们只是 JS 表达式而已。你只需要在一个标签的子节点内(非最外层)小心地用 {} 包围要注释的部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> content = (</span><br><span class="line">  &lt;Nav&gt;</span><br><span class="line">    &#123;/* 一般注释, 用 &#123;&#125; 包围 */&#125;</span><br><span class="line">    &lt;Person</span><br><span class="line">      /* 多</span><br><span class="line">         行</span><br><span class="line">         注释 */</span><br><span class="line">      name=&#123;window.isLoggedIn ? window.name : ''&#125; // 行尾注释</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/Nav&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="1-2、JSX的延展属性"><a href="#1-2、JSX的延展属性" class="headerlink" title="1.2、JSX的延展属性"></a>1.2、JSX的延展属性</h2><p>Props 应该被当作禁止修改的。修改 props 对象可能会导致预料之外的结果，所以最好不要去修改 props 对象。</p>
<h3 id="延展属性（Spread-Attributes）"><a href="#延展属性（Spread-Attributes）" class="headerlink" title="延展属性（Spread Attributes）"></a>延展属性（Spread Attributes）</h3><p>这个<code>...</code>操作符（也被叫做延展操作符 － spread operator）已经被 ES6 数组 支持。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> props = &#123; foo: <span class="string">'default'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> component = &lt;Component &#123;...props&#125; foo=&#123;'override'&#125; /&gt;;</span><br><span class="line">console.log(component.props.foo); // 'override'</span><br></pre></td></tr></table></figure>
<h2 id="1-3、JSX的陷阱"><a href="#1-3、JSX的陷阱" class="headerlink" title="1.3、JSX的陷阱"></a>1.3、JSX的陷阱</h2><h3 id="HTML实体"><a href="#HTML实体" class="headerlink" title="HTML实体"></a>HTML实体</h3><p>如果想在 JSX 表达式中显示 HTML 实体，可以会遇到二次转义的问题，因为 React 默认会转义所有字符串，为了防止各种 XSS 攻击。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误: 会显示 “First &amp;middot; Second”</span></span><br><span class="line">&lt;div&gt;&#123;<span class="string">'First &amp;middot; Second'</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<ul>
<li>直接使用Unicode字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;<span class="string">'First · Second'</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用Unicode编号</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;'First \u00b7 Second'&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&#123;'First ' + String.fromCharCode(183) + ' Second'&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在数组里面使用字符串和JSX元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;[<span class="string">'First '</span>, &lt;span&gt;&amp;middot;&lt;/span&gt;, <span class="string">' Second'</span>]&#125;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用原始HTML</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: <span class="string">'First &amp;middot; Second'</span>&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="自定义HTML属性"><a href="#自定义HTML属性" class="headerlink" title="自定义HTML属性"></a>自定义HTML属性</h3><p>React里面如果需要使用自定义属性，要加 data- 前缀。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-custom-attribute</span>=<span class="string">"foo"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="2、富交互性的动态用户界面"><a href="#2、富交互性的动态用户界面" class="headerlink" title="2、富交互性的动态用户界面"></a>2、富交互性的动态用户界面</h1><h2 id="2-1、事件处理与合成事件（Synthetic-Events）"><a href="#2-1、事件处理与合成事件（Synthetic-Events）" class="headerlink" title="2.1、事件处理与合成事件（Synthetic Events）"></a>2.1、事件处理与合成事件（Synthetic Events）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.initializeTouchEvents(<span class="literal">true</span>); 启用触摸事件处理。</span><br></pre></td></tr></table></figure>
<h2 id="2-2、幕后原理：自动绑定和事件代理"><a href="#2-2、幕后原理：自动绑定和事件代理" class="headerlink" title="2.2、幕后原理：自动绑定和事件代理"></a>2.2、幕后原理：自动绑定和事件代理</h2><p>在幕后，React 做了一些操作来让代码高效运行且易于理解。</p>
<p><code>Autobinding</code>: 在 JavaScript 里创建回调的时候，为了保证 this 的正确性，一般都需要显式地绑定方法到它的实例上。有了 React，所有方法被自动绑定到了它的组件实例上。</p>
<p><code>事件代理</code>: React 实际并没有把事件处理器绑定到节点本身。</p>
<h2 id="2-3、组件其实是状态机（State-Machines）"><a href="#2-3、组件其实是状态机（State-Machines）" class="headerlink" title="2.3、组件其实是状态机（State Machines）"></a>2.3、组件其实是状态机（State Machines）</h2><p>React 把用户界面当作简单状态机。把用户界面想像成拥有不同状态然后渲染这些状态，可以轻松让用户界面和数据保持一致。</p>
<p>React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。React 来决定如何最高效地更新 DOM。</p>
<h2 id="2-4、State-工作原理"><a href="#2-4、State-工作原理" class="headerlink" title="2.4、State 工作原理"></a>2.4、State 工作原理</h2><p>常用的通知 React 数据变化的方法是调用 setState(data, callback)。这个方法会合并（merge） data 到 this.state，并重新渲染组件。渲染完成后，调用可选的 callback 回调。</p>
<h2 id="2-5、哪些组件应该有-State？"><a href="#2-5、哪些组件应该有-State？" class="headerlink" title="2.5、哪些组件应该有 State？"></a>2.5、哪些组件应该有 State？</h2><p>有时需要对用户输入、服务器请求或者时间变化等作出响应，这时才需要使用 State。</p>
<h2 id="2-6、哪些-应该-作为-State？"><a href="#2-6、哪些-应该-作为-State？" class="headerlink" title="2.6、哪些 应该 作为 State？"></a>2.6、哪些 应该 作为 State？</h2><p>State 应该包括那些可能被组件的事件处理器改变并触发用户界面更新的数据。</p>
<h2 id="2-7、哪些-不应该-作为-State？"><a href="#2-7、哪些-不应该-作为-State？" class="headerlink" title="2.7、哪些 不应该 作为 State？"></a>2.7、哪些 不应该 作为 State？</h2><p>this.state 应该仅包括能表示用户界面状态所需的最少数据。因此，它不应该包括：</p>
<ul>
<li>计算所得数据</li>
<li>React组件</li>
<li>基于props的重复数据</li>
</ul>
<h1 id="3、复合组件"><a href="#3、复合组件" class="headerlink" title="3、复合组件"></a>3、复合组件</h1><h2 id="3-1、动机：关注分离"><a href="#3-1、动机：关注分离" class="headerlink" title="3.1、动机：关注分离"></a>3.1、动机：关注分离</h2><p>通过复用那些接口定义良好的组件来开发新的模块化组件，我们得到了与使用函数和类相似的好处。</p>
<h2 id="3-2、组合实例"><a href="#3-2、组合实例" class="headerlink" title="3.2、组合实例"></a>3.2、组合实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Avatar = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ProfilePic username=&#123;this.props.username&#125; /&gt;</span><br><span class="line">        &lt;ProfileLink username=&#123;this.props.username&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var ProfilePic = React.createClass(&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;img src=&#123;'http://graph.facebook.com/' + this.props.username + '/picture'&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var ProfileLink = React.createClass(&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;a href=&#123;'http://www.facebook.com/' + this.props.username&#125;&gt;</span><br><span class="line">        &#123;this.props.username&#125;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">  &lt;Avatar username="pwh" /&gt;,</span><br><span class="line">  document.getElementById('example')</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="3-3、从属关系"><a href="#3-3、从属关系" class="headerlink" title="3.3、从属关系"></a>3.3、从属关系</h2><p>组件不能修改自身的 props - 它们总是与它们拥有者设置的保持一致。这是保持用户界面一致性的关键性原则。</p>
<h2 id="3-4、子级"><a href="#3-4、子级" class="headerlink" title="3.4、子级"></a>3.4、子级</h2><p>实例化 React 组件时，你可以在开始标签和结束标签之间引用在React 组件或者Javascript 表达式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;<span class="xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><code>Parent</code>能通过专门的<code>this.props.children props</code>读取子级。<code>this.props.children</code>是一个不透明的数据结构： 通过<code>React.Children</code>工具类 来操作。</p>
<h2 id="3-5、子级校正（Reconciliation）"><a href="#3-5、子级校正（Reconciliation）" class="headerlink" title="3.5、子级校正（Reconciliation）"></a>3.5、子级校正（Reconciliation）</h2><p>校正就是每次 render 方法调用后 React 更新 DOM 的过程。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 第一次渲染</span><br><span class="line">&lt;Card&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;</span><br><span class="line">&lt;/Card&gt;</span><br><span class="line">// 第二次渲染</span><br><span class="line">&lt;Card&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;</span><br><span class="line">&lt;/Card&gt;</span><br></pre></td></tr></table></figure>
<p>React 是根据子级的顺序来校正的。</p>
<h2 id="3-6、子组件状态管理"><a href="#3-6、子组件状态管理" class="headerlink" title="3.6、子组件状态管理"></a>3.6、子组件状态管理</h2><p>对于使用 this.state 来在多次渲染过程中里维持数据的状态化组件，上面例子这样做潜在很多问题。</p>
<p>多数情况下，可以通过隐藏组件而不是删除它们来绕过这些问题。</p>
<h2 id="3-7、动态子级"><a href="#3-7、动态子级" class="headerlink" title="3.7、动态子级"></a>3.7、动态子级</h2><p>如果子组件位置会改变（如在搜索结果中）或者有新组件添加到列表开头（如在流中）情况会变得更加复杂。</p>
<p>果子级要在多个渲染阶段保持自己的特征和状态，在这种情况下，你可以通过给子级设置惟一标识的 key 来区分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = <span class="keyword">this</span>.props.results;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      &#123;results.map(function(result) &#123;</span><br><span class="line">        return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;result.id&#125;</span>&gt;</span>&#123;result.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>务必 把 key 添加到子级数组里组件本身上，而不是每个子级内部最外层 HTML 上。</p>
<p>也可以传递 object 来做有 key 的子级。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.props.results.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 result.id 看起来是一个数字（比如短哈希），那么</span></span><br><span class="line">    <span class="comment">// 对象字面量的顺序就得不到保证。这种情况下，需要添加前缀</span></span><br><span class="line">    <span class="comment">// 来确保 key 是字符串。</span></span><br><span class="line">    items[<span class="string">'result-'</span> + result.id] = <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;result.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      &#123;items&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-8、数据流"><a href="#3-8、数据流" class="headerlink" title="3.8、数据流"></a>3.8、数据流</h2><p>数据通过上面介绍过的 props 从拥有者流向归属者。这就是高效的单向数据绑定(one-way data binding)</p>
<h2 id="3-9、性能提醒"><a href="#3-9、性能提醒" class="headerlink" title="3.9、性能提醒"></a>3.9、性能提醒</h2><p>能的瓶颈大多是因为 DOM 更新，而非 JS 执行，而且 React 会通过批量更新和变化检测来优化性能。</p>
<p>有时候需要做细粒度的性能控制。这种情况下，可以重写 shouldComponentUpdate() 方法返回 false 来让 React 跳过对子树的处理。</p>
<p>不要低估 JavaScript 的速度，DOM 操作通常才是慢的原因。</p>
<p>自己实现一个单向数据绑定？</p>
<h1 id="4、可复用组件"><a href="#4、可复用组件" class="headerlink" title="4、可复用组件"></a>4、可复用组件</h1><p>把通用的设计元素（按钮，表单框，布局组件等）拆成接口良好定义的可复用的组件。</p>
<h2 id="4-1、Prop-验证"><a href="#4-1、Prop-验证" class="headerlink" title="4.1、Prop 验证"></a>4.1、Prop 验证</h2><p>React.PropTypes 提供很多验证器 (validator) 来验证传入数据的有效性。当向 props 传入无效数据时，JavaScript 控制台会抛出警告。注意为了性能考虑，只在开发环境验证 propTypes。</p>
<h2 id="4-2、默认-Prop-值"><a href="#4-2、默认-Prop-值" class="headerlink" title="4.2、默认 Prop 值"></a>4.2、默认 Prop 值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentWithDefaultProps = React.createClass(&#123;</span><br><span class="line">  getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: <span class="string">'default value'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当父级没有传入 props 时，getDefaultProps() 可以保证 this.props.value 有默认值，注意 getDefaultProps 的结果会被 缓存。得益于此，你可以直接使用 props，而不必写手动编写一些重复或无意义的代码。</p>
<h2 id="4-3、传递-Props：小技巧"><a href="#4-3、传递-Props：小技巧" class="headerlink" title="4.3、传递 Props：小技巧"></a>4.3、传递 Props：小技巧</h2><p>JSX 的 spread 语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CheckLink = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这样会把 CheckList 所有的 props 复制到 &lt;a&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">a</span> &#123;<span class="attr">...this.props</span>&#125;&gt;</span>&#123;'√ '&#125;&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">CheckLink</span> <span class="attr">href</span>=<span class="string">"/checked.html"</span>&gt;</span></span><br><span class="line">    Click here!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">CheckLink</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="4-4、单个子级"><a href="#4-4、单个子级" class="headerlink" title="4.4、单个子级"></a>4.4、单个子级</h2><p>React.PropTypes.element 可以限定只能有一个子级传入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent = React.createClass(&#123;</span><br><span class="line">  propTypes: &#123;</span><br><span class="line">    children: React.PropTypes.element.isRequired</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;this.props.children&#125; // 有且仅有一个元素，否则会抛异常。</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="4-5、Mixins"><a href="#4-5、Mixins" class="headerlink" title="4.5、Mixins"></a>4.5、Mixins</h2><p>有时一些复杂的组件间也需要共用一些功能。有时会被称为<code>跨切面关注点</code>。React 使用<code>mixins</code>来解决这类问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SetIntervalMixin = &#123;</span><br><span class="line">  componentWillMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intervals = [];</span><br><span class="line">  &#125;,</span><br><span class="line">  setInterval: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intervals.push(setInterval.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intervals.map(clearInterval);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TickTock = React.createClass(&#123;</span><br><span class="line">  mixins: [SetIntervalMixin], <span class="comment">// 引用 mixin</span></span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;seconds: <span class="number">0</span>&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setInterval(<span class="keyword">this</span>.tick, <span class="number">1000</span>); <span class="comment">// 调用 mixin 的方法</span></span><br><span class="line">  &#125;,</span><br><span class="line">  tick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;seconds: <span class="keyword">this</span>.state.seconds + <span class="number">1</span>&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        React has been running for &#123;this.state.seconds&#125; seconds.</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">TickTock</span> /&gt;</span>,</span><br><span class="line">  document.getElementById('example')</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<h1 id="5、传递Props"><a href="#5、传递Props" class="headerlink" title="5、传递Props"></a>5、传递Props</h1><p>可以使用 JSX 展开属性 来合并现有的 props 和其它值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return &lt;Component &#123;...this.props&#125; more=&quot;values&quot; /&gt;;</span><br></pre></td></tr></table></figure>
<p>也可以使用一些对象辅助方法如 ES6 的 Object.assign 或 Underscore _.extend。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Component(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.props, &#123; more: <span class="string">'values'</span> &#125;));</span><br></pre></td></tr></table></figure>
<h2 id="5-1、手动传递"><a href="#5-1、手动传递" class="headerlink" title="5.1、手动传递"></a>5.1、手动传递</h2><p>大部分情况下你应该显式地向下传递 props。这样可以确保只公开你认为是安全的内部 API 的子集。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> FancyCheckbox = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fancyClass = <span class="keyword">this</span>.props.checked ? <span class="string">'FancyChecked'</span> : <span class="string">'FancyUnchecked'</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;fancyClass&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.onClick&#125;</span>&gt;</span></span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">React.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">FancyCheckbox</span> <span class="attr">checked</span>=<span class="string">&#123;true&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;console.log.bind(console)&#125;</span>&gt;</span></span><br><span class="line">    Hello world!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">FancyCheckbox</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="5-2、在-JSX-里使用-…-传递"><a href="#5-2、在-JSX-里使用-…-传递" class="headerlink" title="5.2、在 JSX 里使用 … 传递"></a>5.2、在 JSX 里使用 … 传递</h2><p>有时把所有属性都传下去是不安全或啰嗦的。这时可以使用<code>解构赋值</code>中的剩余属性特性来把未知属性批量提取出来。</p>
<p>列出所有要当前使用的属性，后面跟着<code>...other</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; checked, ...other &#125; = <span class="keyword">this</span>.props;</span><br></pre></td></tr></table></figure>
<p>这样能确保把所有 props 传下去，除了 那些已经被使用了的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FancyCheckbox = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> &#123; checked, ...other &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">var</span> fancyClass = checked ? <span class="string">'FancyChecked'</span> : <span class="string">'FancyUnchecked'</span>;</span><br><span class="line">    <span class="comment">// `other` 包含 &#123; onClick: console.log &#125; 但 checked 属性除外</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> &#123;<span class="attr">...other</span>&#125; <span class="attr">className</span>=<span class="string">&#123;fancyClass&#125;</span> /&gt;</span>  // 继续往下传递其他的属性</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">React.render(</span><br><span class="line">  <span class="tag">&lt;<span class="name">FancyCheckbox</span> <span class="attr">checked</span>=<span class="string">&#123;true&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;console.log.bind(console)&#125;</span>&gt;</span></span><br><span class="line">    Hello world!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">FancyCheckbox</span>&gt;</span>,</span><br><span class="line">  document.body</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<p>在传递这些未知的<code>other</code>属性时，要经常使用解构赋值模式。</p>
<h2 id="5-3、使用和传递同一个-Prop"><a href="#5-3、使用和传递同一个-Prop" class="headerlink" title="5.3、使用和传递同一个 Prop"></a>5.3、使用和传递同一个 Prop</h2><p>如果组件需要使用一个属性又要往下传递，可以直接使用<code>checked={checked}</code>再传一次。这样做比传整个<code>this.props</code>对象要好，因为更利于重构和语法检查。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FancyCheckbox = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> &#123; checked, title, ...other &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">var</span> fancyClass = checked ? <span class="string">'FancyChecked'</span> : <span class="string">'FancyUnchecked'</span>;</span><br><span class="line">    <span class="keyword">var</span> fancyTitle = checked ? <span class="string">'X '</span> + title : <span class="string">'O '</span> + title;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...other</span>&#125;  // 顺序很重要，把 &#123;<span class="attr">...other</span>&#125; 放到 <span class="attr">JSX</span> <span class="attr">props</span> 前面会使它不被覆盖。</span><br><span class="line">          <span class="attr">checked</span>=<span class="string">&#123;checked&#125;</span></span><br><span class="line">          <span class="attr">className</span>=<span class="string">&#123;fancyClass&#125;</span></span><br><span class="line">          <span class="attr">type</span>=<span class="string">"checkbox"</span></span><br><span class="line">        /&gt;</span></span><br><span class="line">        &#123;fancyTitle&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span></span><br></pre></td></tr></table></figure>
<h2 id="5-4、剩余属性和展开属性-…"><a href="#5-4、剩余属性和展开属性-…" class="headerlink" title="5.4、剩余属性和展开属性 …"></a>5.4、剩余属性和展开属性 …</h2><p>剩余属性可以把对象剩下的属性提取到一个新的对象。会把所有在解构赋值中列出的属性剔除。</p>
<p>这是 ES7 草案 中的试验特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; x, y, ...z &#125; = &#123; x: <span class="number">1</span>, y: <span class="number">2</span>, a: <span class="number">3</span>, b: <span class="number">4</span> &#125;;</span><br><span class="line">x; <span class="comment">// 1</span></span><br><span class="line">y; <span class="comment">// 2</span></span><br><span class="line">z; <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 JSX 命令行工具 配合 –harmony 标记来启用 ES7 语法。</p>
</blockquote>
<h2 id="5-5、使用-Underscore-来传递"><a href="#5-5、使用-Underscore-来传递" class="headerlink" title="5.5、使用 Underscore 来传递"></a>5.5、使用 Underscore 来传递</h2><p>在不适用JSX的情况下，可以使用一些库来实现相同的效果，如<code>Undersocre</code>。</p>
<h1 id="6、表单组件"><a href="#6、表单组件" class="headerlink" title="6、表单组件"></a>6、表单组件</h1><blockquote>
<p>表单事件：onChange onInput onSubmit</p>
</blockquote>
<h2 id="6-1、交互属性"><a href="#6-1、交互属性" class="headerlink" title="6.1、交互属性"></a>6.1、交互属性</h2><p>表单组件支持几个受用户交互影响的属性：</p>
<ul>
<li>value，用于 <input>、<textarea> 组件。</textarea></li>
<li>checked，用于类型为 checkbox 或者 radio 的 <input> 组件。</li>
<li>selected，用于 <option> 组件。</option></li>
</ul>
<h2 id="6-2、受限组件"><a href="#6-2、受限组件" class="headerlink" title="6.2、受限组件"></a>6.2、受限组件</h2><p>设置了 value 的 <input> 是一个受限组件。相当于设置了只读属性。</p>
<p>如果想响应更新用户输入的值，就得使用 onChange 事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;value: <span class="string">'Hello!'</span>&#125;;</span><br><span class="line">&#125;,</span><br><span class="line">handleChange: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">&#125;,</span><br><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="keyword">this</span>.state.value;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="6-3、不受限组件"><a href="#6-3、不受限组件" class="headerlink" title="6.3、不受限组件"></a>6.3、不受限组件</h2><p>没有设置 value(或者设为 null) 的 <input> 组件是一个不受限组件。</p>
<p>如果想给组件设置一个非空的初始值，可以使用 defaultValue 属性。</p>
<h2 id="6-4、高级主题"><a href="#6-4、高级主题" class="headerlink" title="6.4、高级主题"></a>6.4、高级主题</h2><h3 id="为什么使用受限组件？"><a href="#为什么使用受限组件？" class="headerlink" title="为什么使用受限组件？"></a>为什么使用受限组件？</h3><p>在 HTML 中将渲染初始值为 Untitled 的输入框。用户改变输入框的值时，节点的 value 属性（property）将随之变化，但是 node.getAttribute(‘value’) 还是会返回初始设置的值 Untitled.</p>
<p>与 HTML 不同，<code>React 组件必须在任何时间点描绘视图的状态</code>，而不仅仅是在初始化时。比如在 React 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"title"</span> <span class="attr">value</span>=<span class="string">"Untitled"</span> /&gt;</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>该方法在任何时间点渲染组件以后，输入框的值就应该始终为 Untitled。</p>
<h3 id="为什么-使用-value-属性？"><a href="#为什么-使用-value-属性？" class="headerlink" title="为什么  使用 value 属性？"></a>为什么 <textarea> 使用 value 属性？</textarea></h3><p>React 是 JavaScript，没有字符限制，可以使用 \n 实现换行。简言之，React 已经有 value、defaultValue 属性， 组件的子</p>
<p>如果非要*使用子节点，效果和使用 defaultValue 一样。</p>
<h3 id="为什么-使用-value-属性"><a href="#为什么-使用-value-属性" class="headerlink" title="为什么  使用 value 属性"></a>为什么 <select> 使用 value 属性</select></h3><p>React 为了更方面的控制组件。</p>
<blockquote>
<p>给 value 属性传递一个数组，可以选中多个选项：<select multiple="{true}" value="{['B'," 'c']}="">。</select></p>
</blockquote>
<h1 id="7、浏览器中的工作原理"><a href="#7、浏览器中的工作原理" class="headerlink" title="7、浏览器中的工作原理"></a>7、浏览器中的工作原理</h1><p>React提供了强大的抽象，让你在大多数应用场景中不再直接操作DOM，但是有时你需要简单地调用底层的API，或者借助于第三方库或已有的代码。</p>
<h2 id="7-1、虚拟DOM"><a href="#7-1、虚拟DOM" class="headerlink" title="7.1、虚拟DOM"></a>7.1、虚拟DOM</h2><p>React是很快的，因为它从不直接操作DOM。React在内存中维护一个快速响应的DOM描述。render()方法返回一个DOM的描述，React能够利用内存中的描述来快速地计算出差异，然后更新浏览器中的DOM。</p>
<p>有时你简单地需要调用底层的API，或许借助于第三方的类似于jQuery插件这种库。React为你提供了直接使用底层DOM API的途径。</p>
<h2 id="7-2、Refs和getDOMNode"><a href="#7-2、Refs和getDOMNode" class="headerlink" title="7.2、Refs和getDOMNode()"></a>7.2、Refs和getDOMNode()</h2><p>每一个挂载的React组件有一个getDOMNode()方法，你可以调用这个方法来获取对该节点的引用。</p>
<p>getDOMNode()仅在挂载的组件上有效。在创建组件的render()函数中调用getDOMNode()，将会抛出异常。</p>
<p>为了获取一个到React组件的引用，你可以使用this来得到当前的React组件，或者你可以使用refs来指向一个你拥有的组件。</p>
<h2 id="7-3、组件生命周期"><a href="#7-3、组件生命周期" class="headerlink" title="7.3、组件生命周期"></a>7.3、组件生命周期</h2><ul>
<li>挂载： 组件被插入到DOM中。</li>
<li>更新： 组件被重新渲染，查明DOM是否应该刷新。</li>
<li>移除： 组件从DOM中移除。</li>
</ul>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><blockquote>
<p><code>getInitialState()</code> object在组件被挂载之前调用。状态化的组件应该实现这个方法，返回初始的state数据。<br><code>componentWillMount()</code> 在挂载发生之前立即被调用。<br><code>componentDidMount()</code> 在挂载结束之后马上被调用。需要DOM节点的初始化操作应该放在这里。</p>
</blockquote>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><blockquote>
<p><code>componentWillReceiveProps(object nextProps)</code>当一个挂载的组件接收到新的props的时候被调用。该方法应该用于比较this.props和nextProps，然后使用this.setState()来改变state。<br><code>shouldComponentUpdate(object nextProps, object nextState)</code> boolean当组件做出是否要更新DOM的决定的时候被调用。实现该函数，优化this.props和nextProps，以及this.state和nextState的比较，如果不需要React更新DOM，则返回false。<br><code>componentWillUpdate(object nextProps, object nextState)</code> 在更新发生之前被调用。你可以在这里调用this.setState()。<br><code>componentDidUpdate(object prevProps, object prevState)</code> 在更新发生之后调用。</p>
</blockquote>
<h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><p><code>componentWillUnmount()</code>在组件移除和销毁之前被调用。清理工作应该放在这里。</p>
<h3 id="挂载的方法（Mounted-Methods）"><a href="#挂载的方法（Mounted-Methods）" class="headerlink" title="挂载的方法（Mounted Methods）"></a>挂载的方法（Mounted Methods）</h3><p>挂载的复合组件也支持如下方法：</p>
<ul>
<li><code>getDOMNode()</code>: DOMElement可以在任何挂载的组件上面调用，用于获取一个指向它的渲染DOM节点的引用。</li>
<li><code>forceUpdate()</code>: 当你知道一些很深的组件state已经改变了的时候，可以在该组件上面调用，而不是使用this.setState()。</li>
</ul>
<h2 id="7-4、跨浏览器支持和兼容代码"><a href="#7-4、跨浏览器支持和兼容代码" class="headerlink" title="7.4、跨浏览器支持和兼容代码"></a>7.4、跨浏览器支持和兼容代码</h2><p>在Facebook，我们支持低版本的浏览器，包括IE8。</p>
<h1 id="8、关于Refs的更多内容"><a href="#8、关于Refs的更多内容" class="headerlink" title="8、关于Refs的更多内容"></a>8、关于Refs的更多内容</h1><p>input 元素一些东西 - 这些东西过会儿（onClick，onChange事件后）之后已无法从它的 props 中推算出来。在这个场景中，我们想“通知” input 元素，现在应该处于获取焦点状态。然而，此处有一些障碍。从 render() 中返回的内容并不是你实际创建的子组件的组合，仅仅是一个某一刻某个组件实例的 描述 - 一个快照。</p>
<blockquote>
<p>记住，从 render() 中返回的内容并不是实际渲染出来的子组件实例。从 render() 返回的仅仅是子组件层级树实例在特定时间的一个描述。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counterexample: DO NOT DO THIS!</span></span><br><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myInput = <span class="xml"><span class="tag">&lt;<span class="name">input</span> /&gt;</span>;          // I'm going to try to call methods on this</span><br><span class="line">  this.rememberThisInput = myInput; // input at some point in the future! YAY!</span><br><span class="line">  return (</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      &#123;myInput&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在这个反例中，<input> 仅仅是一个 <input> 组件的描述。该描述用于创建一个真正的 <input> 的<code>支撑实例</code>（ backing instance ）。为了获取真正的Input的支撑实力，我们需要使用到ref属性</p>
<h2 id="8-1、ref-属性"><a href="#8-1、ref-属性" class="headerlink" title="8.1、ref 属性"></a>8.1、ref 属性</h2><p>React 支持一种非常特殊的属性，你可以用来绑定到 render() 输出的任何组件上去。这个特殊的属性允许你引用 render() 返回的相应的<code>支撑实例</code>（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。</p>
<ul>
<li>1、绑定一个 ref 属性到 render 返回的东西上面去</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=<span class="string">"myInput"</span> /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、在其它代码中（典型地事件处理代码），通过 this.refs 获取支撑实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.refs.myInput</span><br></pre></td></tr></table></figure>
<h1 id="9、工具集成"><a href="#9、工具集成" class="headerlink" title="9、工具集成"></a>9、工具集成</h1><h2 id="9-1、React"><a href="#9-1、React" class="headerlink" title="9.1、React"></a>9.1、React</h2><h2 id="9-2、JSX"><a href="#9-2、JSX" class="headerlink" title="9.2、JSX"></a>9.2、JSX</h2>
      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 arthinking
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>