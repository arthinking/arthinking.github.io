<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JVM笔记 - 高效并发（线程安全与锁优化） | arthinking | ChinSyun Pang&#39;s blog</title>
  <meta name="author" content="arthinking">
  
  <meta name="description" content="Struggle for HighPay zoom.">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="JVM笔记 - 高效并发（线程安全与锁优化）"/>
  <meta property="og:site_name" content="arthinking"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="arthinking" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">arthinking</a>
  </h1>
  <p class="site-description">ChinSyun Pang&#39;s blog</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        <article class="post article">

  
  
    <h3 class="article-title"><span>JVM笔记 - 高效并发（线程安全与锁优化）</span></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120801_JVM笔记 - 高效并发（线程安全与锁优化）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#1、概述</p>
<p>#2、线程安全</p>
<p>##2.1、Java语言中的线程安全<br>按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程建荣和线程对立。</p>
<p>###不可变</p>
<p>不可变的对象一定是线程安全的。</p>
<p>保证对象行为不影响自己状态的途径有很多种，其中最简单的就是把对象中带有状态的变量都声明为final。</p>
<p>Java API中符合不可变要求的类型：String，java.lang.Number的部分子类（如Long和Double的数值包装类，BigInteger和BigDecimal等大数据类型但<code>AtomicInteger</code>和<code>AtomicLong</code>则并非不可变的）。</p>
<p>###绝对线程安全<br>Java API中标注自己是线程安全的类，大多数都不是绝对线程安全的。</p>
<p>###相对线程安全<br>Java语言中，大部分的线程安全都属于这种类型，例如Vector，HashTable，Collections的synchronizedCollection()方法包装的集合等。</p>
<p>###线程兼容<br>指通过使用同步手段来保证对象在并发环境中可以安全的使用。Java API中大部分的类都是属于线程兼容的，如ArrayList和HashMap。</p>
<p>###线程对立<br>指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。</p>
<p>一个线程对立的例子就是Thread类的suspend()和resumn()方法（已被JDK声明废弃了）。</p>
<p>常见的线程对立操作还有System.setIn(), System.setOut(), System.runFinalizersOnExit()…</p>
<p>##2.2、线程安全的实现方法</p>
<p>###互斥同步<br>Java中，最基本的互斥同步手段就是synchronized关键字。</p>
<p>synchronized是一个重量级的操作，因为：Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要消耗很多的处理器时间。对于代码简单的同步块（如synchronized修饰的getter()和setter方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>还可以使用java.util.concurrent包中的<code>ReentrantLock(重入锁)</code>来实现同步：JDK1.5多线程环境下synchronized的吞吐量下降的很严重，而ReentrantLock则基本保持在同一个比较稳定的水平上。JDK 1.6之后两者性能基本持平。</p>
<p>虚拟机在未来的性能改进中还会更偏向于原生的synchronize的，所以还是<br>提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。</p>
<p>###非阻塞同步<br>非阻塞同步：从处理问题的方式上说，互斥同步属于一种悲观的并发策略。随着硬件指令集的发展，我们可以采用基于冲突检查的乐观并发策略，通俗地说，就是先行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现偶读不需要把线程挂起，因此这话总同步操作称为非阻塞同步。</p>
<p>###无同步方案<br>如果一个方法本来就不设计共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。这类代码包括：可重入代码和线程本地存储。</p>
<p>#3、锁优化<br>为了进一步改进高效并发，HotSpot虚拟机开发团队在JDK1.6版本上花费了大量精力实现各种锁优化。</p>
<p>##3.1、自旋锁与自适应自旋<br>为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。引入自旋锁的原因是互斥同步对性能最大的影响是阻塞的实现，管钱线程和恢复线程的操作都需要转入内核态中完成，给并发带来很大压力。自旋锁让物理机器有一个以上的处理器的时候，能让两个或以上的线程同时并行执行。</p>
<p>##3.2、锁消除<br>消除锁是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p>
<p>##3.3、锁粗化<br>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，则可以进行锁粗化的优化。</p>
<p>##3.4、轻量级锁<br>它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<p>但是如果存在锁竞争，除了互斥量的开销，还发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p>
<p>##3.5、偏向锁<br>如果说轻量级锁是在无竞争的情况下使用了CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉了，连CAS操作都不做了。</p>
<p>#4、本章小结</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>

  



      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 arthinking
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>