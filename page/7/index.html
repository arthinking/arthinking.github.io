<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 7 | arthinking | ChinSyun Pang&#39;s blog</title>
  <meta name="author" content="arthinking">
  
  <meta name="description" content="Struggle for HighPay zoom.">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:site_name" content="arthinking"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="arthinking" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">arthinking</a>
  </h1>
  <p class="site-description">ChinSyun Pang&#39;s blog</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        
  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2015030901_为什么不建议调用sun包，如何通过其他方法确定调用者/"><span>为什么不建议调用sun包，如何通过其他方法确定调用者</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2015030901_为什么不建议调用sun包，如何通过其他方法确定调用者/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#获取调用者信息的方法</p>
<p>一般的，我们可以通过堆栈信息获取调用当前方法的类名和方法名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过堆栈信息获取调用当前方法的类名和方法名</span></span><br><span class="line">String className = <span class="string">""</span>;</span><br><span class="line">String methodName = <span class="string">""</span>;</span><br><span class="line">Class clazz = <span class="keyword">null</span>;</span><br><span class="line">StackTraceElement[] elements = <span class="keyword">new</span> Throwable().getStackTrace();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++)&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.getClass().getName().equals(elements[i].getClassName()))&#123;</span><br><span class="line">      <span class="comment">// 获取堆栈的下一个元素，就是调用者元素</span></span><br><span class="line">      <span class="comment">// 如果想要获取当前方法所在类的信息，直接读取elements[i]就可以了</span></span><br><span class="line">      className = elements[i + <span class="number">1</span>].getClassName();</span><br><span class="line">      methodName = elements[i + <span class="number">1</span>].getMethodName();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(className + <span class="string">"."</span> + methodName + <span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure></p>
<p>该方法也可以获取调用代码所在的行号的类所在的文件，但是这种方法不能获得调用者的类型，因为不知道调用者的的类装载器，所以也就不能使用Class.forName(String)得到类型。</p>
<p>可以尝试使用以下方法获得调用者的类型（但该方法不建议使用，后面有说明）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clazz = Reflection.getCallerClass(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"invoker's class loader: "</span> + clazz.getClassLoader() + <span class="string">"\nclass name: "</span> + clazz.getName());</span><br></pre></td></tr></table></figure>
<p>该方法比使用堆栈的效率高，如果想要获取当前方法所在类的信息，调用 Reflection.getCallerClass(1) 就可以了，Reflection.getCallerClass(0) 是Reflection对象</p>
<p>#为什么不建议调用sun包</p>
<p>这篇文章中提到了JDK 8弃用 sun.reflect.Reflection.getCallerClass：</p>
<blockquote>
<p><a href="http://www.infoq.com/cn/news/2013/07/Oracle-Removes-getCallerClass" target="_blank" rel="external">http://www.infoq.com/cn/news/2013/07/Oracle-Removes-getCallerClass</a></p>
</blockquote>
<p>但后来又决定保留下来了：</p>
<blockquote>
<p><a href="http://www.infoq.com/cn/news/2013/08/Oracle-Resurrects-getCallerClass" target="_blank" rel="external">http://www.infoq.com/cn/news/2013/08/Oracle-Resurrects-getCallerClass</a></p>
</blockquote>
<p>JDK 8 实际上新特性如下</p>
<blockquote>
<p><a href="http://www.iteye.com/news/28870-java-8-release" target="_blank" rel="external">http://www.iteye.com/news/28870-java-8-release</a></p>
</blockquote>
<p>其中 JEP 176：自动检测识别Caller-Sensitive方法：</p>
<blockquote>
<p><a href="http://openjdk.java.net/jeps/176" target="_blank" rel="external">http://openjdk.java.net/jeps/176</a></p>
</blockquote>
<p>JDK 8中在getCallerClass方法加了 @sun.reflect.CallerSensitive 注解，该注解是提供给JVM底层读取处理的，提高了JDK实现感知调用者功能的安全性，详细参考：</p>
<blockquote>
<p><a href="http://stackoverflow.com/questions/22626808/what-does-the-sun-reflect-callersensitive-annotation-mean" target="_blank" rel="external">http://stackoverflow.com/questions/22626808/what-does-the-sun-reflect-callersensitive-annotation-mean</a></p>
</blockquote>
<p>查看getCallerClass的<a href="http://cr.openjdk.java.net/~mchung/jdk8/webrevs/8025799/hotspot.00/src/share/vm/prims/jvm.cpp.html" title="底层实现" target="_blank" rel="external">底层实现</a>#668可以发现，当传入了depth的时候，调用了net.reflect.Reflection类的这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@java</span>.lang.Deprecated</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> java.lang.<span class="function">Class <span class="title">getCallerClass</span><span class="params">(<span class="keyword">int</span> arg0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个方法在底层实现中还是通过兼容旧版本的代码去执行的，所以这个方法加了一个 @Deprecated 注解，这也是为什么不推荐上面那种方法获取调用者类型的原因。</p>
<p>类似的， JDK8 中的 @java.lang.Class 的 forName(className) 方法也加了这个注解，因为forName方法里面也调用给到了Reflection.getCallerClass()</p>
<p>Oracle建议开发人员不要使用sun包，但是有一系列的项目都依赖于getCallerClass()方法，如Jigsaw和Lambda，Intellij IDEA。在spring-loaded的<a href="https://github.com/spring-projects/spring-loaded/blob/master/springloaded/src/main/java/org/springsource/loaded/ri/ReflectiveInterceptor.java#L213" title="源码" target="_blank" rel="external">源码</a>，这里也调用了getCallerClass()方法，作为临时的方案去兼容JDK 7u25，需要添加系统属性：jdk.reflect.allowGetCallerClass，参考这里：</p>
<blockquote>
<p><a href="http://permalink.gmane.org/gmane.comp.java.openjdk.jdk7u.devel/6573" target="_blank" rel="external">http://permalink.gmane.org/gmane.comp.java.openjdk.jdk7u.devel/6573</a></p>
</blockquote>
<p>其实查看JDK 7 Reflection的字节码可以发现对这个属性的处理逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static java.lang.Class getCallerClass(int arg0);</span><br><span class="line">     0  invokestatic sun.misc.VM.allowGetCallerClass() : boolean [216]</span><br><span class="line">     3  ifeq 13</span><br><span class="line">     6  iload_0 [arg0]</span><br><span class="line">     7  iconst_1</span><br><span class="line">     8  iadd</span><br><span class="line">     9  invokestatic sun.reflect.Reflection.getCallerClass0(int) : java.lang.Class [217]</span><br><span class="line">    12  areturn</span><br><span class="line">    13  new java.lang.UnsupportedOperationException [112]</span><br><span class="line">    16  dup</span><br><span class="line">    17  ldc &lt;String &quot;This method has been disabled by a system property&quot;&gt; [7]</span><br><span class="line">    19  invokespecial java.lang.UnsupportedOperationException(java.lang.String) [206]</span><br><span class="line">    22  athrow</span><br><span class="line">      Line numbers:</span><br><span class="line">        [pc: 0, line: 68]</span><br><span class="line">        [pc: 6, line: 69]</span><br><span class="line">        [pc: 13, line: 71]</span><br><span class="line">      Stack map table: number of frames 1</span><br><span class="line">        [pc: 13, same]</span><br></pre></td></tr></table></figure></p>
<p>开发者不应该调用sun包，Oracle一直在提醒开发者，调用sun.*包里面的方法是危险的。上面用到的Reflection.getCallerClass()也是在这个包里面的，因为sun包并不包含在Java平台的标准中，它与操作系统相关，在不同的操作系统如Solaris，Windows，Linux，Mac等中的实现也各不相同，并且可能随着JDK版本而变化。详细说明: </p>
<blockquote>
<p><a href="http://www.oracle.com/technetwork/java/faq-sun-packages-142232.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/faq-sun-packages-142232.html</a></p>
</blockquote>
<p>完整例子：</p>
<blockquote>
<p><a href="https://github.com/arthinking/java-code/blob/master/src/main/java/me/arthinking/question/Q_07_stack_trace.java" target="_blank" rel="external">https://github.com/arthinking/java-code/blob/master/src/main/java/me/arthinking/question/Q_07_stack_trace.java</a></p>
</blockquote>
<p>发表于：</p>
<blockquote>
<p><a href="http://www.itzhai.com/get-invoker-by-stacktrace-and-getcallerclass.html" target="_blank" rel="external">http://www.itzhai.com/get-invoker-by-stacktrace-and-getcallerclass.html</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/Java/">Java</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/Refection/">Refection</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/javascript/seajs/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/javascript/seajs/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在使用spm之前，首先得安装nodejs，因为spm是nodejs的一个package。<a href="http://qianduanblog.com/post/js-learning-42-using-spm-3-build-seajs-project.html" title="使用spm@3构建seajs项目" target="_blank" rel="external">使用spm@3构建seajs项目</a></p>
<p><a href="http://spmjs.io/documentation" title="spm 3官方教程" target="_blank" rel="external">spm 3官方教程</a></p>
<p>构建目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dist  构建目标文件夹</span><br><span class="line">examples  相关使用文档</span><br><span class="line">spm_modules   依赖的js文件仓库，spm install的时候下载到里面</span><br><span class="line">tests  测试案例</span><br><span class="line">xx.js  </span><br><span class="line">package.json  spm维护的依赖配置文件，用于生产dist目录的相关配置</span><br></pre></td></tr></table></figure></p>
<p><a href="http://spmjs.io/package/expect.js" title="expectjs" target="_blank" rel="external">expectjs</a></p>
<p><a href="http://chaoskeh.com/blog/why-its-hard-to-combo-seajs-modules.html" title="为什么 SeaJS 模块的合并这么麻烦" target="_blank" rel="external">为什么 SeaJS 模块的合并这么麻烦</a></p>
<p>###安装nodejs</p>
<p><a href="http://seajs.org/docs/#docs" title="seajs" target="_blank" rel="external">seajs</a></p>
<p>配置NODE_PATH</p>
<p><a href="http://segmentfault.com/blog/yinchangsheng/1190000002478924" title="nodejs 中的 NODE_PATH" target="_blank" rel="external">nodejs 中的 NODE_PATH</a></p>
<p>windows下需要安装<a href="http://gnuwin32.sourceforge.net/packages/make.htm" title="make" target="_blank" rel="external">make</a></p>
<p>下载<a href="https://github.com/seajs/examples" title="demo" target="_blank" rel="external">demo</a>编译执行</p>
<p>SeaJS遵循<a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" title="CMD" target="_blank" rel="external">CMD</a>规范，一个模块就是一个文件，通过<code>require</code> 关键词引入外部模块，每次加载需要直接使用到的模块的时候，模块内部 <code>require</code> 进来的js也会一并加载，为了让SeaJS在加载之前把所有相关联的JS都能够通过一个JS文件一次性加载进来，就需要用到SeaJS的<a href="http://www.zhihu.com/question/20789867/answer/16187950" title="Transport" target="_blank" rel="external">Transport</a>格式<br>没转换前Modules/Wrappingsgui规范格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">   var a = require(&quot;a&quot;)</span><br><span class="line">   exports.foo = ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>CMD模块在正式上线前，通过构建工具（如SPM）先转换为Modules/Transport格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(&quot;id&quot;, [&quot;dep-1&quot;, &quot;dep-2&quot;], function(require, exports, module) &#123;</span><br><span class="line">   // source code</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>进一步通过构建工具，就可以一并吧 <code>require</code> 引入进来的模块一起压缩合并到同一个文件中了。</p>
<p>##说明<br>简单来说，通过使用SeaJS，我们可以把JS代码模块化，在上线之前，通过spm这样的构建工具，把自己开发的模块压缩合并，当成SeaJS的一个模块来使用。</p>
<p>##Step by step</p>
<p>下面一步一步来实现这个过程：</p>
<p>##正面项目接口</p>
<p>整体目录结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">project   // 项目跟目录 </span><br><span class="line">|</span><br><span class="line">|-assets  // web资源文件</span><br><span class="line">  |</span><br><span class="line">  |- sea-modules  // SeaJS相关模块</span><br><span class="line">  |  </span><br><span class="line">  |- static  // 模块开发路径</span><br><span class="line">  |   |</span><br><span class="line">  |   |- first-module</span><br><span class="line">  |       |- dist  // 我的模块构建目标文件夹</span><br><span class="line">  |       |- src  // 我的模块开发文件夹</span><br><span class="line">  |       |- package.json  // spm编译配置</span><br><span class="line">  |</span><br><span class="line">  |- app  // 我的模块使用例子</span><br><span class="line">  |</span><br></pre></td></tr></table></figure></p>
<p>##创建目录结构</p>
<p>###step1、创建项目 project</p>
<p>###step2、创建web资源文件夹<br>在project里面新建一个assetsweb资源文件夹，专门用来存放JS，CSS等资源，我们的模块开发就在这个目录下面进行</p>
<p>###step3、在assets下面创建sea-modules文件夹<br>这个文件夹是用来存放SeaJS模块的，我们需要用到的模块，包括自己实现的模块最终都要存放到这里</p>
<p>###step4、在assets目录下创建 static 文件夹<br>这个文件夹用于模块开发</p>
<p>###step5、在 static 目录下创建 first-module 文件夹<br>这个文件夹用于存储我的第一个模块的开发代码</p>
<p>###step6、在 first-module 目录下创建 src 目录，这个目录用于存放我们模块开发的代码</p>
<p>###step7、在assets下面创建 app 文件夹<br>这个文件夹存放我们演示调用模块代码的HTML文件</p>
<p>##使用spm初始化构建</p>
<p>###首先你需要通过npm安装spm，而npm是Node.js里面的一个工具，所以你需要先这样搭建环境：</p>
<ul>
<li>安装<a href="http://nodejs.org/" title="Node.js" target="_blank" rel="external">Node.js</a></li>
<li>安装spm<br>目前最新的是3版本的，建议安装最新的，详细可以参考官方文档：<br><a href="http://spmjs.io/documentation/getting-started" title="spmjs.io" target="_blank" rel="external">http://spmjs.io/</a><br>这里只要在cmd里面执行以下一句就可以了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install spm -g</span><br></pre></td></tr></table></figure>
<ul>
<li>使用spm初始化项目目录</li>
</ul>
<p>在first-module目录下执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spm init</span><br></pre></td></tr></table></figure>
<p>接下来按照提示分表填写 Package name, Version, Description, Author即可。</p>
<p>执行完之后生成如下目录：<br><img src="" alt=""></p>
<p>接下来就可以开始开发自己的模块了。</p>
<p>##模块开发</p>
<p>###编辑我们自己的模块代码<br>在src目录下创建我们的模块代码 index.js</p>
<p><a href="http://blog.csdn.net/huyoo/article/details/21703701" target="_blank" rel="external">http://blog.csdn.net/huyoo/article/details/21703701</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120501_JVM笔记 - 程序编译与代码优化（早期（编译器）优化）/"><span>JVM笔记 - 程序编译与代码优化（早期（编译器）优化）</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120501_JVM笔记 - 程序编译与代码优化（早期（编译器）优化）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#1、概述<br>Java语言的“编译期”是一段不确定的操作过程，可能是：    </p>
<ul>
<li>前端编译器（编译器的前端）把Java文件转换为class文件；Sun 的 Javac、 Eclipse   JDT 中的增量式编译器（ ECJ）[ 1]。</li>
<li>后端编译器（JIT编译期 Just in time compiler）把字节码变成机器码；JIT 编译器： HotSpot   VM 的 C1、 C2 编译器。</li>
<li>静态编译器（AOT编译器 ahead of time compiler）直接把Java编译成本地机器代码；</li>
<li>AOT 编译器： GNU   Compiler   for   the   Java（ GCJ）[ 2]、 Excelsior JET[ 3]。</li>
</ul>
<p>本章讨论第一类编译过程。</p>
<p>Javac 这类编译器对代码的运行效率几乎没有任何优化措施（在 JDK   1. 3 之后， Javac 的- O 优化参数就不再有意义）。虚拟机设计团队把对性能的优化集中到了后端的即时编译器中。</p>
<p>#2、Javac编译器<br>它本身就是一个由 Java 语言编写的程序，这为纯 Java 的程序员了解它的编译过程带来了很大的便利。</p>
<p>##2.1、Javac的源码与调试</p>
<p>##2.2、解析与填充符号表</p>
<p>##2.3、注解处理器<br>提供了一组插入式注解处理器的标准 API 在编译期间对注解进行处理。</p>
<p>有了编译器注解处理的标准 API 后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。</p>
<p>在 Javac 源码中，插入式注解处理器的初始化过程是在 initPorcessAnnotations() 方法中完成的，而它的执行过程则是在processAnnotations() 方法中完成的。</p>
<p>##2.4、语义分析与字节码生成<br>编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。</p>
<p>是否合乎语义逻辑必须限定在具体的语言与具体的上下文环境之中才有意义。</p>
<blockquote>
<p>标注检查 Javac 的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤。</p>
</blockquote>
<p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠。</p>
<p>由于编译期间进行了常量折叠，所以在代码里面定义” a= 1+ 2” 比起直接定义” a= 3”， 并不会增加程序运行期哪怕仅仅一个 CPU 指令的运算量。</p>
<blockquote>
<p>数据及控制流分析</p>
</blockquote>
<p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。</p>
<p>将局部变量声明为 final， 对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有 CONSTANT<em> Fieldref</em> info 的符号引用，自然就没有访问标志（ Access_ Flags） 的信息。</p>
<blockquote>
<p>解语法糖</p>
</blockquote>
<p>在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。</p>
<p>解语法糖的过程由 desugar() 方法触发。</p>
<blockquote>
<p>字节码生成</p>
</blockquote>
<p>字节码生成是 Javac 编译过程的最后一个阶段</p>
<p>把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。例如，前面章节中多次提到的实例构造器＜ init ＞()方法和类构造器＜ clinit ＞()方法就是在这个阶段添加到语法树之中的</p>
<p>还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为 StringBuffer 或 StringBuilder。</p>
<p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给 com. sun. tools. javac. jvm. ClassWriter 类，由这个类的 writeClass() 方法输出字节码，生成最终的 Class 文件，到此为止整个编译过程宣告结束。</p>
<p>#3、Java语法糖的味道</p>
<p>##3.1、泛型与类型擦除<br>Java 语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（ Raw   Type， 也称为裸类型）了，并且在相应的地方插入了强制转型代码。</p>
<p>泛型擦除成相同的原生类型只是无法重载的其中一部分原因。</p>
<p>方法重载要求方法具备不同的特征签名，返回值并不包含在方法的特征签名之中，所以返回值不参与重载选择，但是在 Class 文件格式之中，只要描述符不是完全一致的两个方法就可以共存。也就是说，两个方法如果有相同的名称和特征签名，但返回值不同，那它们也是可以合法地共存于一个 Class 文件中的。</p>
<p>link</p>
<p>Signature、 LocalVariableTypeTable 等新的属性用于解决伴随泛型而来的参数类型的识别问题， Signature 是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名[ 3]， 这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。</p>
<p>由于 List ＜ String ＞和 List ＜ Integer ＞擦除后是同一个类型，我们只能添加两个并不需要实际使用到的返回值才能完成重载。</p>
<p>擦除法所谓的擦除，仅仅是对方法的 Code 属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。</p>
<p>##3.2、自动装箱、拆箱与遍历循环<br>遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现 Iterable 接口的原因。</p>
<p>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，以及它们 equals() 方法不处理数据转型的关系，笔者建议在实际编码中尽量避免这样使用自动装箱与拆箱。</p>
<p>##3.3、条件编译<br>Java 语言当然也可以进行条件编译，方法就是使用条件为常量的 if 语句。</p>
<p>#4、实战：插入式注解处理器</p>
<p>##4.1、实战目标</p>
<p>##4.2、代码实现<br>要通过注解处理器 API 实现一个编译器插件，首先需要了解这组 API 的一些基本知识。</p>
<p>在 JDK   1. 6 新增的 javax. lang. model 包中定义了 16 类 Element， 包括了 Java 代码中最常用的元素，如：“包（ PACKAGE）、 枚举（ ENUM）、 类（ CLASS）、 注解（ ANNOTATION<em> TYPE）、 接口（ INTERFACE）、 枚举值（ ENUM</em> CONSTANT）、 字段（ FIELD）、 参数（ PARAMETER）、 本地变量（ LOCAL<em> VARIABLE）、 异常（ EXCEPTION</em> PARAMETER）、 方法（ METHOD）、 构造函数（ CONSTRUCTOR）、 静态语句块（ STATIC<em> INIT， 即 static{} 块）、实例语句块（ INSTANCE</em> INIT， 即{}块）、参数化类型（ TYPE_ PARAMETER， 既泛型尖括号内的类型）和未定义的其他语法树节点（ OTHER）”。</p>
<p>##4.3、运行与测试</p>
<p>##4.4、其他应用案例<br>NameCheckProcessor 的实战例子只演示了 JSR- 269 嵌入式注解处理器 API 中的一部分功能，基于这组 API 支持的项目还有用于校验 Hibernate 标签使用正确性的 Hibernate   Validator   Annotation Processor[ 1]（ 本质上与 NameCheckProcessor 所做的事情差不多）、自动为字段生成 getter 和 setter 方法的 Project   Lombok[ 2]（ 根据已有元素生成新的语法树元素）等。</p>
<p>#5、本章小结<br>之所以把 Javac 这类将 Java 代码转变为字节码的编译器称做“前端编译器”，是因为它只完成了从程序到抽象语法树或中间字节码的生成，而在此之后，还有一组内置于虚拟机内部的“后端编译器”完成了从字节码生成本地机器码的过程，即前面多次提到的即时编译器或 JIT 编译器，这个编译器的编译速度及编译结果的优劣，是衡量虚拟机性能一个很重要的指标。</p>
<blockquote>
<p>Javac(Java在编译时)做了哪些事情</p>
<pre><code>1、解析与填充符号表；    
2、注解处理器；    
3、语义分析与字节码生成：    
    3.1、标注检查    
    3.2、数据及控制流分析    
    3.3、解语法糖    
        3.3.1、泛型与类型擦除    
        3.3.2、自动装箱、拆箱与遍历循环    
        3.3.3、条件编译    
    3.4、字节码生成
</code></pre><p>后端编译器把字节码转换成本地机器码    </p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120601_JVM笔记 - 程序编译与代码优化（晚期（运行期）优化）/"><span>JVM笔记 - 程序编译与代码优化（晚期（运行期）优化）</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120601_JVM笔记 - 程序编译与代码优化（晚期（运行期）优化）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#1、概述<br>即时编译器并不是虚拟机必需的部分。</p>
<p>本章提及的编译器、即时编译器都是指 HotSpot 虚拟机内的即时编译器，虚拟机也是特指 HotSpot 虚拟机。</p>
<p>#2、HotSpot虚拟机内的即时编译器</p>
<p>##2.1、解释器与编译器<br>HotSpot 虚拟机中内置了两个即时编译器，分别称为 Client Compiler 和 Server   Compiler。</p>
<p>HotSpot 虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用”- client” 或”- server” 参数去强制指定虚拟机运行在 Client 模式或 Server 模式。</p>
<p>参数”- Xint” 强制虚拟机运行于“解释模式”（ Interpreted   Mode）。</p>
<p>参数”- Xcomp” 强制虚拟机运行于“编译模式”（ Compiled   Mode），这时将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。</p>
<p>为了在程序启动响应速度与运行效率之间达到最佳平衡， HotSpot 虚拟机还会逐渐启用分层编译（ Tiered Compilation）[ 4] 的策略。</p>
<p>实施分层编译后， Client   Compiler 和 Server   Compiler 将会同时工作，许多代码都可能会被多次编译，用 Client   Compiler 获取更高的编译速度，用 Server   Compiler 来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。</p>
<p>##2.2、编译对象与触发条件<br>“热点代码”有两类，即：被多次调用的方法。被多次执行的循环体。</p>
<p>这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为栈上替换（ On   Stack   Replacement， 简称为 OSR 编译，即方法栈帧还在栈上，方法就被替换了）。</p>
<p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测。</p>
<p>目前主要的热点探测判定方式有两种：基于采样的热点探测，基于计数器的热点探测。</p>
<p>在 HotSpot 虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两类计数器：方法调用计数器（ Invocation   Counter） 和回边计数器（ Back   Edge   Counter）。</p>
<p>当计数器超过阈值溢出了，就会触发 JIT 编译。</p>
<p>当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的。</p>
<p>使用虚拟机参数- XX:- UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数。</p>
<p>使用- XX: CounterHalfLifeTime 参数设置半衰周期的时间，单位是秒。</p>
<p>回边计数器，它的作用是统计一个方法中循环体代码执行的次数。<br>建立回边计数器统计的目的就是为了触发 OSR 编译。<br>参数- XX: OnStackReplacePercentage 来间接调整回边计数器的阈值。</p>
<p>##2.3、编译过程<br>在默认设置下，无论是方法调用产生的即时编译请求，还是 OSR 编译请求，虚拟机在代码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线程中进行。</p>
<p>用户可以通过参数- XX:- BackgroundCompilation 来禁止后台编译。</p>
<p>对于 Client   Compiler 来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。</p>
<p>而 Server Compiler 则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器,也是一个充分优化过的高级编译器,几乎能达到 GNU C++编译器使用-O2参数时的优化强度。</p>
<p>##2.4、查看及分析即时编译结果</p>
<p>#3、编译优化技术</p>
<p>##3.1、优化技术概览<br>这些代码优化变换是建立在代码的某种中间表示或机器码之上，绝不是建立在Java源码之上的。</p>
<p>##3.2、公共子表达式消除</p>
<p>##3.3、数组边界检查消除<br>除了如数组边界检查优化这种尽可能把运行期检查提到编译器完成的思路之外，另外还有一种避免思路：隐式异常处理。</p>
<p>当 foo 不为空的时候,对 value 的访问是不会额外消耗一次对 foo 判空的开销的。代价就是当 foo 真的为空时,必须转入到异常处理器中恢复并抛出 NullPointException异常，这个过程必须从用户态转动内核态中处理，结束后再回到用户态，速度远比一次判空检查慢。</p>
<p>##3.4、方法内联<br>只有使用invokespecial指令调用的私有方法、实例构造器、父类方法以及使用invokestatic指令进行调用的静态方法才是在编译期进行解析的。</p>
<p>##3.5、逃逸分析<br>逃逸分析的基本行为就是分析对象动态作用域。</p>
<p>如果确定一个方法不会逃逸出方法之外，那让整个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧而销毁。在一般应用中，不会逃逸的局部对象所占用的比例很大，如果能使用栈上分配，那大量的对象就会随着方法结束而自动销毁了，垃圾手机系统的压力将会小很多。</p>
<p>同步消除</p>
<p>标量替换</p>
<p>#4、Java与C/C++的编译器对比<br>除了它们自身的API库实现得好坏之外，其余的比较就成了一场“拼编译器”和“拼输出代码质量”的游戏。</p>
<p>Java虚拟机的即时编译器与C/C++的静态优化编译器相比，可能会由于下列这些原因导致输出的本地代码有一些劣势：<br>即时编译器运行占用的是用户程序的运行时间<br>Java语言是动态的类型安全语言<br>Java语言中虽然没有virtual关键字，但是使用虚方法的频率却远远大于C/C++语言<br>Java语言是可以动态扩展的语言<br>Java语言中对象的内存分配都是在堆上进行的，只有方法中的局部变量才能在堆上分配</p>
<p>#5、本章小结</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120701_JVM笔记 - 高效并发（Java内存模型与线程）/"><span>JVM笔记 - 高效并发（Java内存模型与线程）</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120701_JVM笔记 - 高效并发（Java内存模型与线程）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#1、概述</p>
<p>#2、硬件的效率与一致性<br>基于告诉缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来了更高的复杂度，因为它引入了一个新的问题：缓存一致性。</p>
<p>处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的。</p>
<p>#3、Java内存模型<br>线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行。</p>
<p>##3.1、主内存与工作内存</p>
<p>##3.2、内存间交互操作</p>
<p>##3.3、对于volatile型变量的特殊规则</p>
<p>当一个变量定义为volitile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性。</p>
<hr>
<p>volitile变量在各个线程中是一致的，并不能得出基于volitile变量的运算在并发下是安全的这个结论。</p>
<p>volatile变量的运算在并发下一样是不安全的。</p>
<p>当getstatic指令把变量的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把变量的值加大了。</p>
<p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性：</p>
<ul>
<li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程变量的值。</p>
</li>
<li><p>变量不需要与其他的状态变量共同参与不变约束。</p>
</li>
</ul>
<p>使用volatile变量的第二个语义是禁止指令重排优化。</p>
<hr>
<p>普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p>
<p>指令重排是并发编程中最容易让开发人员产生疑惑的地方，volitile关键字可以禁止指令重排序优化。</p>
<p>volatile变量读取操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要再笨的代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁第，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。</p>
<blockquote>
<p>如一个变量的修改不依赖与原值，则这个时候可以使用volatile关键字实现先行发生关系。</p>
</blockquote>
<p>##3.4、对于long和double型变量的特殊规则<br>在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编码时一般不需要把用到的long和double变量专门声明为volatile。</p>
<p>##3.5、原子性、可见性与有序性</p>
<p>###原子性<br>由Java内存模型来直接保证的原子性变量操作包括：read、load、assign、use、store和write。</p>
<p>###可见性<br>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p>
<p>除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。</p>
<p>###有序性<br>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
<p>大部分并发控制都能使用synchronized来完成。synchronized的“万能”也间接早就了它被程序员滥用的局面，越“万能”的并发控制，通常会伴随着越大的性能影响。</p>
<p>##3.6、先行发生原则<br>依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<p>下面是Java内存模型下一些“天然的”先行发生关系：</p>
<ul>
<li>程序次序规则</li>
<li>管程锁定规则</li>
<li>volatile变量规则</li>
<li>线程启动规则</li>
<li>线程终止规则</li>
<li>线程中断规则</li>
<li>对象终结规则</li>
<li>传递性</li>
</ul>
<p>#4、Java与线程</p>
<p>##4.1、线程的实现<br>Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的。</p>
<p>实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</p>
<p>###使用内核线程实现<br>由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要再用户态和内核态中来回切换。</p>
<p>###使用用户线程实现</p>
<p>###使用用户线程加轻量级进程混合实现</p>
<p>###Java线程的实现</p>
<p>##4.2、Java线程调度<br>分为协同式线程调度和抢占式线程调度。Java使用的线程调度方式就是抢占式调度。</p>
<p>线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统。</p>
<p>##4.3、状态转换</p>
<p>###以下方法会让线程陷入无限期的等待状态：</p>
<ul>
<li>没有设置Timeout参数的Object.wait()方法</li>
<li>没有设置Timeout参数的Thread.join()方法</li>
<li>LockSupport.park()方法</li>
</ul>
<p>以下方法会让线程进入限期等待状体：</p>
<ul>
<li>Thread.sleep()</li>
<li>设置了Timeout参数的Object.wait()方法</li>
<li>设置了Timeout参数的Thread.join()方法</li>
<li>LockSupport.parkNanos()方法</li>
<li>LockSupport.parkUntil()方法</li>
</ul>
<p>#5、本章小结</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120401_JVM笔记 - 虚拟机执行子系统（类加载及执行子系统的案例与实战）/"><span>JVM笔记 - 虚拟机执行子系统（类加载及执行子系统的案例与实战）</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120401_JVM笔记 - 虚拟机执行子系统（类加载及执行子系统的案例与实战）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#1、概述<br>能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能。</p>
<p>#2、案例分析</p>
<p>##2.1、Tomcat：正统的类加载器架构<br>主流的 Java   Web 服务器，如 Tomcat、 Jetty、 WebLogic、 WebSphere 或其他笔者没有列举的服务器，都实现了自己定义的类加载器（一般都不止一个）。因为一个功能健全的 Web 服务器，要解决如下几个问题：    </p>
<blockquote>
<p>部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以实现相互隔离。</p>
<p>部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以互相共享。</p>
<p>服务器需要尽可能地保证自身的安全不受部署的 Web 应用程序影响。</p>
<p>支持 JSP 应用的 Web 服务器，大多数都需要支持 HotSwap 功能。</p>
</blockquote>
<p>在部署 Web 应用时，单独的一个 ClassPath 就无法满足需求了，所以各种 Web 服务器都“不约而同”地提供了好几个 ClassPath 路径供用户存放第三方类库。</p>
<p>在 Tomcat 目录结构中，有 3 组目录（”<code>/common/*</code>“、”<code>/server/*</code>“ 和”<code>/shared/*</code>“） 可以存放 Java 类库，另外还可以加上 Web 应用程序自身的目录”/ WEB- INF/*”， 一共 4 组。</p>
<p><code>CommonClassLoader</code>、 <code>CatalinaClassLoader</code>、 <code>SharedClassLoader</code> 和 <code>WebappClassLoader</code> 则是 Tomcat 自己定义的类加载器，</p>
<p>###Tomcat热部署原理<br>JasperLoader 的加载范围仅仅是这个 JSP 文件所编译出来的那一个 Class， 它出现的目的就是为了被丢弃：当服务器检测到 JSP 文件被修改时，会替换掉目前的 JasperLoader 的实例，并通过再建立一个新的 Jsp 类加载器来实现 JSP 文件的 HotSwap 功能。</p>
<p>对于 Tomcat 的 6. x 版本，只有指定了 tomcat/conf/ catalina. properties 配置文件的 server.loader 和 share.loader 项后才会真正建立 CatalinaClassLoader 和 SharedClassLoader 的实例，否则会用到这两个类加载器的地方都会用 CommonClassLoader 的实例代替，而默认的配置文件中没有设置这两个 loader 项，所以 Tomcat 6.x 顺理成章地把/common、/server 和/shared 三个目录默认合并到一起变成一个/ lib 目录。</p>
<p>##2.2、OSGi：灵活的类加载器架构<br>“学习 JEE 规范，去看 JBoss 源码；学习类加载器，就去看 OSGi 源码”。</p>
<p>OSGi 在 Java 程序员中最著名的应用案例就是Eclipse IDE。</p>
<p>一个 Bundle 可以声明它所依赖的 Java   Package（ 通过 Import- Package 描述），也可以声明它允许导出发布的 Java   Package（ 通过 Export- Package 描述）。</p>
<p>一个模块里只有被 Export 过的 Package 才可能由外界访问。</p>
<p>基于 OSGi 的程序很可能（只是很可能，并不是一定会）可以实现模块级的热插拔功能，当程序升级更新或调试除错时，可以只停用、重新安装然后启用程序的其中一部分。</p>
<p>OSGi 的 Bundle 类加载器之间只有规则，没有固定的委派关系。</p>
<p>只有具体使用某个 Package 和 Class 的时候，才会根据 Package 导入导出定义来构造 Bundle 间的委派和依赖。</p>
<p>如果一个类存在于 Bundle 的类库中但是没有被 Export， 那么这个 Bundle 的类加载器能找到这个类，但不会提供给其他 Bundle 使用</p>
<p>并非所有的应用都适合采用 OSGi 作为基础架构， OSGi 在提供强大功能的同时，也引入了额外的复杂度，带来了线程死锁和内存泄漏的风险。</p>
<p>##2.3、字节码生成技术与动态代理的实现<br>javac 也是一个由 Java 语言写成的程序，它的代码存放在 OpenJDK 的 langtools/src/share/classes/com/ sun/tools/javac 目录中[ 1]。 要深入了解字节码生成，阅读 javac 的源码是个很好的途径。</p>
<p>动态代理实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。调用了 sun.misc.ProxyGenerator.generateProxyClass() 方法来完成生成字节码的动作，这个方法可以在运行时产生一个描述代理类的字节码 byte[] 数组。</p>
<p>##2.4、Retrotranslator：跨越JDK版本<br>一种名为“ Java 逆向移植”的工具（ Java Backporting Tools）应运而生， Retrotranslator[1] 是这类工具中较出色的一个。</p>
<p>编译器在程序中使用到<code>包装对象</code>的地方自动插入了很多 Integer.valueOf()、 Float.valueOf() 之类的代码；<code>变长参数</code>在编译之后就自动转化成了一个数组来完成参数传递；<code>泛型</code>的信息则在编译阶段就已经擦除掉了（但是在元数据中还保留着），相应的地方被编译器自动插入了类型转换代码[ 2]。</p>
<p>从字节码的角度来看，<code>枚举</code>仅仅是一个继承于 java. lang. Enum、 自动生成了 values() 和 valueOf() 方法的普通 Java 类而已。</p>
<p>#3、实战：自己动手实现远程执行功能</p>
<p>##3.1、目标</p>
<p>##3.2、思路</p>
<p>##3.3、实现<br>构造函数中指定为加载 HotSwapClassLoader 类的类加载器作为父类加载器，这一步是实现提交的执行代码可以访问服务端引用类库的关键。</p>
<p>##3.4、验证</p>
<p>#4、本章小结</p>
<blockquote>
<p>《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》笔记</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120303_参数验证问题  AOP or  过滤器/"><span>参数验证问题  AOP or  过滤器</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120303_参数验证问题  AOP or  过滤器/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>使用Spring的AOP，之恩能够操作Spring上下文里面的对象。   </p>
<p>JSP编译成的Class文件，是切入不了的，JSP编译为Servlet，JSP编译后的类的实例又servlet容器进行管理，对应的，可以通过Servlet的过滤器进行扩展。    </p>
<p>##下面使用过滤器过滤验证参数：    </p>
<p>如页面大小，页数这些通用的参数验证，可以抽取出通用的逻辑放入到Filter中处理。    </p>
<p>对于使用Controller实现的接口，我们可以使用AOP进行拦截验证参数，而对于JSP页面，我们就只能使用Filter进行过滤验证了。    </p>
<p>##JSP请求整个处理流程如下：</p>
<ul>
<li>客户端发起HTTP请求</li>
<li>服务器端Web Server接受到请求，把请求转交给容器</li>
<li>容器获取到请求的url</li>
<li>容器根据web.xml中配置的filter，判断请求url是否需要执行filter</li>
<li>容器根据web.xml中的配置，找到URL对应的Servlet（如果没有找到该Servlet，直接返回404错误码到客户端，表示访问的资源不存在）</li>
<li>调用servlet的service方法处理请求（如果servlet还未装载入虚拟机，则进行加载，连接，并实例化，整个时候会调用servlet的init()方法，该方法只调用一次），分配一个线程去执行</li>
<li>如果Servlet实例需要在容器中移除的时候，则调用servlet实例的destroy方法，以便释放实例所使用的资源，并持久化数据，之后等待GC回收。</li>
</ul>
<p>##Spring Controller请求整个处理流程如下：</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/Java/">Java</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/AOP/">AOP</a>, <a href="/tags/Filter/">Filter</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/HTTP协议/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/HTTP协议/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>##HTTP协议返回码，301,302</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/operating-system/linux/vim/"><span>VIM常用命令</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/operating-system/linux/vim/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>##选择<br>选中： v<br>取消选择：再按一下v    </p>
<p>矩形选区：ctrl + v</p>
<p>全选：ggVG</p>
<p>###选中后的操作<br>d  删除<br>y  复制<br>p  粘贴<br>“+y<br>“+p</p>
<p>##复制<br>single line：yy<br>muitl line:nyy<br>copy block to destination:6,9 co 12    </p>
<p>##粘贴<br>paste：p    </p>
<p>##删除<br>x  删除一个字符<br>dd  删除一整行</p>
<p>##撤销<br>u</p>
<p>##重做<br>ctrl + r</p>
<p>##合并<br>J  合并两行    </p>
<p>##退出保存<br>ZZ    </p>
<p><a href="http://blog.csdn.net/ithomer/article/details/5929428" title="more" target="_blank" rel="external">more</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/IDE/">IDE</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/VIM/">VIM</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/javascript/main/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/javascript/main/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        console.log('This would be the main JS file.');

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/6/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/8/" class="pagination-next">Next</a>
  
</nav>
      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 arthinking
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>