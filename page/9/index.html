<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 9 | arthinking | ChinSyun Pang&#39;s blog</title>
  <meta name="author" content="arthinking">
  
  <meta name="description" content="Struggle for HighPay zoom.">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:site_name" content="arthinking"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="arthinking" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">arthinking</a>
  </h1>
  <p class="site-description">ChinSyun Pang&#39;s blog</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        
  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120302_JVM笔记 - 虚拟机执行子系统（虚拟机字节码执行引擎）/"><span>JVM笔记 - 虚拟机执行子系统（虚拟机字节码执行引擎）</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120302_JVM笔记 - 虚拟机执行子系统（虚拟机字节码执行引擎）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
<p>《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》笔记</p>
</blockquote>
<p>#1、概述<br>物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p>
<p>#2、运行时栈帧结构<br>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。</p>
<p>对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧。</p>
<p>##2.1、局部变量表<br>Java 语言中明确的（ reference 类型则可能是 32 位也可能是 64 位） 64 位的数据类型只有 long 和 double 两种。</p>
<p>为了尽可能节省栈帧空间，局部变量表中的 Slot 是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体。</p>
<p>局部变量表复用对垃圾收集的影响 link<br>placeholder 原本所占用的 Slot 还没有被其他变量所复用，所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。</p>
<p>书籍《 Practical Java》 中把“不使用的对象应手动赋值为 null” 作为一条推荐的编码规则，，赋 null 值的操作在经过 JIT 编译优化后就会被消除掉，这时候将变量设置为 null 就是没有意义的。</p>
<p>代码清单 8- 2 在经过 JIT 编译后， System.gc() 执行时就可以正确地回收掉内存，无须写成代码清单 8- 3 的样子。</p>
<p>局部变量不像前面介绍的类变量那样存在“准备阶段”。如果一个局部变量定义了但没有赋初始值是不能使用的。</p>
<p>##2.2、操作数栈</p>
<p>##2.3、动态连接<br>Class 文件的常量池中存有大量的符号引用。</p>
<p>这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为<code>静态解析</code>。另外一部分将在每一次运行期间转化为直接引用，这部分称为<code>动态连接</code>。</p>
<p>##2.4、方法返回地址<br>方法退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。</p>
<p>##2.5、附加信息</p>
<p>#3、方法调用</p>
<p>##3.1、解析<br>调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（ Resolution）。</p>
<p>在 Java 语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，因此它们都适合在类加载阶段进行解析。</p>
<p>在 Java 虚拟机里面提供了 5 条方法调用字节码指令，分别如下。<br>&gt;</p>
<blockquote>
<p>invokestatic： 调用静态方法。</p>
<p>invokespecial： 调用实例构造器＜ init ＞方法、私有方法和父类方法。</p>
<p>invokevirtual： 调用所有的虚方法。</p>
<p>invokeinterface： 调用接口方法，会在运行时再确定一个实现此接口的对象。</p>
<p>只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法 4 类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。    </p>
</blockquote>
<p>这些方法可以称为<code>非虚方法</code>，与之相反，其他方法称为<code>虚方法</code>（除去 final 方法）    </p>
<p>Java 中的非虚方法除了使用 invokestatic、 invokespecial 调用的方法之外还有一种，就是被 <code>final</code> 修饰的方法。</p>
<p><code>解析调用</code>一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而<code>分派（ Dispatch） 调用</code>则可能是静态的也可能是动态的，根据分派依据的宗量数[ 1] 可分为单分派和多分派。</p>
<p>##3.2、分派</p>
<p>###静态分派：    </p>
<p>例子：link</p>
<p>“ Human” 称为变量的静态类型（ Static   Type）， 或者叫做的外观类型（ Apparent   Type）， 后面的” Man” 则称为变量的实际类型（ Actual   Type）。    </p>
<p>虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。    </p>
<p>所有依赖静态类型来定位方法执行版本的分派动作称为<code>静态分派</code>。</p>
<p>重载方法匹配优先级 link    </p>
<p>如果同时出现两个参数分别为 Serializable 和 Comparable ＜ Character ＞的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示类型模糊，拒绝编译。程序必须在调用时显式地指定字面量的静态类型，如： sayHello（（ Comparable ＜ Character ＞）’ a’）。    </p>
<p>###动态分派：</p>
<p>它和多态性的另外一个重要体现[ 3]—— <code>重写</code>（ Override） 有着很密切的关联。</p>
<p>方法动态分派演示 link    </p>
<p>Java 虚拟机是如何根据实际类型来分派方法执行版本的呢？    </p>
<p>原因就需要从 invokevirtual 指令的多态查找过程开始说起，由于 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为<code>动态分派</code>。</p>
<p>###单分派与多分派：</p>
<p>单分派与多分派 link    </p>
<p>Java 语言的<code>静态分派</code>属于<code>多分派类型</code>。    </p>
<p>Java 语言的<code>动态分派</code>属于<code>单分派类型</code>。    </p>
<p>今天（直至还未发布的 Java   1. 8） 的 Java 语言是一门静态多分派、动态单分派的语言。    </p>
<p>###虚拟机动态分派的实现：</p>
<p>##3.3、动态类型语言支持<br>随着 JDK   7 的发布，字节码指令集终于迎来了第一位新成员—— <code>invokedynamic</code>指令。这条新增加的指令是 JDK   7 实现“动态类型语言”（ Dynamically   Typed Language） 支持而进行的改进之一。</p>
<p>###1. 动态类型语言<br>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期。</p>
<p>“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个重要特征。</p>
<p>###2. JDK   1. 7 与动态类型</p>
<p>###3. java. lang. invoke 包    </p>
<p>JDK   1. 7 实现了 JSR- 292， 新加入的 java. lang. invoke 包[ 2] 就是 JSR- 292 的一个重要组成部分。    </p>
<p>MethodHandle演示 link    </p>
<p>MethodHandle 的使用方法和效果与 Reflection 有众多相似之处，不过，它们还是有以下这些区别：    </p>
<blockquote>
<p>Reflection 是在模拟 Java 代码层次的方法调用，而 MethodHandle 是在模拟字节码层次的方法调用。    </p>
<p>Reflection 是重量级，而 MethodHandle 是轻量级。    </p>
<p>Reflection   API 的设计目标是只为 Java 语言服务的，而 MethodHandle 则设计成可服务于所有 Java 虚拟机之上的语言，其中也包括 Java 语言。    </p>
</blockquote>
<p>###4. invokedynamic 指令</p>
<p>在某种程度上， invokedynamic 指令与 MethodHandle 机制的作用是一样的，都是为了解决原有 4 条” invoke*” 指令方法分派规则固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中。</p>
<p>###5. 掌控方法分派规则</p>
<p>invokedynamic 指令与前面 4 条” invoke*” 指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定。</p>
<p>可以通过” super” 关键字很方便地调用到父类中的方法，但如果要访问祖类的方法呢？</p>
<p>使用 MethodHandle 来解决相关问题 link</p>
<p>#4、基于栈的字节码解析执行引擎</p>
<p>##4.1、解析执行<br>Java 语言中， Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。</p>
<p>##4.2、基于栈的指令集与基于寄存器的指令集<br>Java 编译器输出的指令流，基本上[ 1] 是一种基于栈的指令集架构。    </p>
<p>基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供[ 2]， 程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。    </p>
<p>栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。    </p>
<p>虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是，栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的手段，把最常用的操作映射到寄存器中避免直接内存访问，但这也只能是优化措施而不是解决本质问题的方法。由于指令数量和内存访问的原因，所以导致了栈架构指令集的执行速度会相对较慢。</p>
<p>##4.3、基于栈的解析执行过程<br>一段简单的算术代码的字节码表示  link    </p>
<p>在 HotSpot 虚拟机中，有很多以” fast_” 开头的非标准字节码指令用于合并、替换输入的字节码以提升解释执行性能，而即时编译器的优化手段更加花样繁多[ 1]。    </p>
<blockquote>
<p>发表于：<a href="http://www.itzhai.com/jvm-executive-subsystem-bytecode-interpreter.html" title="虚拟机执行子系统（虚拟机字节码执行引擎）" target="_blank" rel="external">虚拟机执行子系统（虚拟机字节码执行引擎）</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120301_JVM笔记 - 虚拟机执行子系统（虚拟机类加载机制）/"><span>JVM笔记 - 虚拟机执行子系统（虚拟机类加载机制）</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120301_JVM笔记 - 虚拟机执行子系统（虚拟机类加载机制）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
<p>《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》笔记</p>
</blockquote>
<p>#1、概述<br>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>
<p>Java 里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>
<p>#2、类加载的时机<br>加载（ Loading）、 验证（ Verification）、 准备（ Preparation）、 解析（ Resolution）、 初始化（ Initialization）、 使用（ Using） 和卸载（ Unloading） 7 个阶段。</p>
<p>其中验证、准备、解析 3 个部分统称为连接（ Linking）。</p>
<p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>
<p>虚拟机规范则是严格规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）： </p>
<blockquote>
<p>1） 遇到 new、 getstatic、 putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 </p>
<p>2） 使用 java. lang. reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。    </p>
<p>3） 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。    </p>
<p>4） 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。    </p>
<p>5） 当使用 JDK   1. 7 的动态语言支持时，如果一个 java. lang. invoke. MethodHandle 实例最后的解析结果 REF<em> getStatic、 REF</em> putStatic、 REF_ invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。    </p>
</blockquote>
<p>通过 子类引用父类的静态字段，不会导致子类初始化。是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。</p>
<p>通过 数组定义来引用类，不会触发此类的初始化。</p>
<p>#3、类加载的过程</p>
<p>##3.1、加载<br>在加载阶段，虚拟机需要完成以下 3 件事情：<br>&gt;<br>1） 通过一个类的全限定名来获取定义此类的二进制字节流。<br>&gt;<br>2） 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>&gt;<br>3） 在内存中生成一个代表这个类的 java. lang. Class 对象，作为方法区这个类的各种数据的访问入口。</p>
<p>Class文件的获取方式：<br>&gt;<br>从 ZIP 包中读取，这很常见，最终成为日后 JAR、 EAR、 WAR 格式的基础。<br>&gt;<br>从网络中获取，这种场景最典型的应用就是 Applet。<br>&gt;<br>运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java. lang. reflect. Proxy 中，就是用了 ProxyGenerator. </p>
<blockquote>
<p>generateProxyClass 来为特定接口生成形式为”*$ Proxy” 的代理类的二进制字节流。<br>由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</p>
<p>从数据库中读取。</p>
</blockquote>
<p>一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的。</p>
<p>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ Element   Type， 指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称为 C） 创建过程就遵循以下规则：</p>
<p>如果数组的组件类型（ Component   Type， 指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（这点很重要，在 7. 4 节会介绍到，一个类必须与类加载器一起确定唯一性）。如果数组的组件类型不是引用类型（例如 int[] 数组）， Java 虚拟机将会把数组 C 标记为与引导类加载器关联。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中。</p>
<p>Class类对象并没有明确规定是在 Java 堆中，对于 HotSpot 虚拟机而言， Class 对象比较特殊，它虽然是对象，但是存放在方法区里面。</p>
<p>##3.2、验证<br>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>在字节码语言层面上，上述 Java 代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p>
<p>验证阶段大致上会完成下面 4 个阶段的检验动作：</p>
<p>###文件格式验证：<br>第一阶段要验证字节流是否符合 Class 文件格式的规范。</p>
<p>###元数据验证：<br>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。</p>
<p>###字节码验证：<br>主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。<br>由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在 JDK 1. 6 之后的 Javac 编译器和 Java 虚拟机中进行了一项优化，给方法体的 Code 属性的属性表中增加了一项名为” StackMapTable” 的属性</p>
<p>###符号引用验证：<br>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。<br>如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用- Xverify: none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p>##3.3、准备<br>这个阶段进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value= <span class="number">123</span>;</span><br></pre></td></tr></table></figure></p>
<p>把 value 赋值为 123 的动作将在初始化阶段才会执行。</p>
<p>特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value= <span class="number">123</span>；</span><br></pre></td></tr></table></figure></p>
<p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。</p>
<p>##3.4、解析<br>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>除 invokedynamic 指令以外，虚拟机实现可以对第一次解析的结果进行缓存。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。</p>
<p>##3.5、初始化<br>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜ clinit ＞()方法的过程。</p>
<p>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p>
<p>虚拟机会保证在子类的＜ clinit ＞()方法执行之前，父类的＜ clinit ＞()方法已经执行完毕。因此在虚拟机中第一个被执行的＜ clinit ＞()方法的类肯定是 java. lang. Object。</p>
<p>父类中定义的静态语句块要优先于子类的变量赋值操作。</p>
<p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜ clinit ＞()方法。但接口与类不同的是，执行接口的＜ clinit ＞()方法不需要先执行父接口的＜ clinit ＞()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的＜ clinit ＞()方法。</p>
<p>虚拟机会保证一个类的＜ clinit ＞()方法在多线程环境中被正确地加锁、同步。</p>
<p>如果在一个类的＜ clinit ＞()方法中有耗时很长的操作，就可能造成多个进程阻塞</p>
<p>#4、类加载器<br>让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>类加载器却在类层次划分、 OSGi、 热部署、代码加密等领域大放异彩。</p>
<p>##4.1、类与类加载器<br>即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>不同的类加载器对 instanceof 关键字运算的结果的影响  link<br>虚拟机中存在了两个 ClassLoaderTest 类，一个是由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的</p>
<p>##4.2、双亲委派模型<br>从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是<code>启动类加载器</code>（ Bootstrap ClassLoader）， 这个类加载器使用 C++ 语言实现[ 1]， 是虚拟机自身的一部分；另一种就是<code>所有其他的类加载器</code>，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java. lang. ClassLoader。</p>
<p>绝大部分 Java 程序都会使用到以下 3 种系统提供的类加载器：</p>
<p>####启动类加载器（ Bootstrap   ClassLoader）：<br>这个类将器负责将存放在＜ JAVA_ HOME ＞\ lib 目录中的，或者被- Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt. jar， 名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。<br>用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用 null 代替即可。</p>
<p>####扩展类加载器（ Extension   ClassLoader）：<br>它负责加载＜ JAVA_ HOME ＞\ lib\ ext 目录中的，或者被 java. ext. dirs 系统变量所指定的路径中的所有类库。    </p>
<p>####应用程序类加载器（ Application   ClassLoader）：<br>由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ ClassPath） 上所指定的类库。</p>
<p>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（ Inheritance） 的关系来实现，而是都使用组合（ Composition） 关系来复用父加载器的代码。</p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。</p>
<p>类 java. lang. Object， 它存放在 rt. jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。<br>可以尝试去编写一个与 rt. jar 类库中已有类重名的 Java 类，将会发现可以正常编译，但永远无法被加载运行。</p>
<p>##4.3、破坏双亲委派模型<br>双亲委派模型的<code>第一次</code>“被破坏”其实发生在双亲委派模型出现之前——即 JDK 1.2 发布之前。    </p>
<p>JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 findClass() 方法中，在 loadClass() 方法的逻辑里如果父类加载失败，则会调用自己的 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。    </p>
<p>双亲委派模型的<code>第二次</code>“被破坏”是由这个模型自身的缺陷所导致的。如果基础类又要调用回用户的代码，那该怎么办？    </p>
<p>为了解决这个问题， Java 设计团队只好引入了一个不太优雅的设计：<code>线程上下文类加载器</code>（ Thread Context   ClassLoader）。</p>
<p>双亲委派模型的<code>第三次</code>“被破坏”是由于用户对程序动态性的追求而导致的。<br>OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（ OSGi 中称为 Bundle） 都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。    </p>
<p>在 Java 程序员中基本有一个共识： OSGi 中对类加载器的使用是很值得学习的，弄懂了 OSGi 的实现，就可以算是掌握了类加载器的精髓。</p>
<p>#5、本章小结</p>
<blockquote>
<p>发表于：<a href="http://www.itzhai.com/jvm-executive-subsystem-class-loading-mechanism.html" title="JVM笔记 - 虚拟机执行子系统（虚拟机类加载机制）" target="_blank" rel="external">JVM笔记 - 虚拟机执行子系统（虚拟机类加载机制）</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120201_JVM笔记 - 虚拟机执行子系统（类文件结构）/"><span>JVM笔记 - 虚拟机执行子系统（类文件结构）</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120201_JVM笔记 - 虚拟机执行子系统（类文件结构）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
<p>《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》笔记    </p>
</blockquote>
<p>#1、概述</p>
<p>#2、无关性的基石<br>JVM 设计者通过 JSR- 292 基本兑现了对 Java 虚拟机进行适当的扩展，以便更好地支持其他语言运行于 JVM 之上这个承诺。</p>
<p>Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与“ Class 文件”这种特定的二进制文件格式所关联</p>
<p>#3、Class类文件的结构<br>任何一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。</p>
<p>Class 文件是一组以 8 位字节为基础单位的二进制流。</p>
<p>根据 Java 虚拟机规范的规定， Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类型为基础。</p>
<p>#4、字节码指令简介</p>
<p>#5、共有设计和私有设计<br>只要优化后 Class 文件依然可以被正确读取，并且包含在其中的语义能得到完整的保持，那实现者就可以选择任何方式去实现这些语义，虚拟机后台如何处理 Class 文件完全是实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可[ 1]。</p>
<p>#6、Class文件结构的发展<br>相对于语言、 API 以及 Java 技术体系中其他方面的变化， Class 文件结构一直处于比较稳定的状态， Class 文件的主体结构、字节码指令的语义和数量几乎没有出现过变动[ 1]， 所有对 Class 文件格式的改进，都集中在向访问标志、属性表这些在设计上就可扩展的数据结构中添加内容。</p>
<p>#7、本章小结</p>
<blockquote>
<p>发表于：<a href="http://www.itzhai.com/jvm-executive-subsystem-class-structure.html" title="JVM笔记 - 虚拟机执行子系统（类文件结构）" target="_blank" rel="external">JVM笔记 - 虚拟机执行子系统（类文件结构）</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120202_更新常量类导致的编译问题/"><span>更新常量类导致的编译问题</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120202_更新常量类导致的编译问题/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
<p>类从被加载到JVM内存开始，到卸载出内存，整个周期包括：加载、验证、准备、解析、初始化、使用和卸载。而虚拟机规范严格规定了有且只有五种情况必须对类进行初始化（link），这几种情况被称为对类的主动引用，其他的情况被称为被动引用（link），其中就包括调用一个类的常量，不会触发定义常量的类的初始化，这是因为常量（字符串类型或基本数据类型）在编译阶段会存入调用类的常量池中。</p>
</blockquote>
<p><strong>问题描述如下：</strong><br>更新一个常量类class到服务器之后，其他引用这个常量的地方并没有做出改动，导致问题的出现。</p>
<p>对常量问题的思考：<br>一般在系统运行事情不会发生变化的东西才可以定义为常量，常量可以硬编码写到代码里面。</p>
<p>对于可能做出调整的常量需要考虑：为了方便编译，不用全局编译一次，哪里用到的常量就定义在哪个类中，或者使用枚举类型替换。<br>参考代码：<br><a href="https://github.com/arthinking/java-code/blob/master/src/me/arthinking/code4jvmnote/C7_4_RoleEnum.java" title="常量编译处理方式" target="_blank" rel="external">常量编译处理方式</a><br>可以发现，数组常量会从所在的类加载元素，而字符串和整型的常量会直接在常量池中保存一份数据，不会除非常量所在类的初始化。</p>
<blockquote>
<p>发表于：<a href="更新常量类导致的编译问题" title="http://www.itzhai.com/the-compilation-problems-caused-by-constant.html">更新常量类导致的编译问题</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/设计模式/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/设计模式/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>##问题</p>
<p>###了解哪些设计模式，6个设计原则分别是什么？每种设计原则体现的设计模式是哪个？</p>
<p>###设计模式书籍，简述。</p>
<p>###设计模式结构图和使用场景</p>
<p>###Spring AOP用了什么设计原则</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/javascript/angularjs/chapter03_module/README/"><span>module</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/javascript/angularjs/chapter03_module/README/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
<p>AngularJS允许我们使用angular.module()方法来声明模块，这个方法能够接受两个参数，第一个是模块的名称，第二个是依赖列表，也就是可以被注入到模块中的对象列表。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法相当于AngularJS模块的setter方法，是用来定义模块的。</span></span><br><span class="line">angular.module(<span class="string">'myApp'</span>, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法用于获取应用，相当于AngularJS模块的getter方法</span></span><br><span class="line">angular.module(<span class="string">'myApp'</span>)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/web前端/">web前端</a>, <a href="/categories/web前端/Javascript/">Javascript</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/AngularJS/">AngularJS</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/params/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/params/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        {"name":"Arthinking.GitHub.io","tagline":"","body":"arthinking的技术总结\r\n----------\r\n这是一个技术总结对比的思考区\r\n\r\n> Author: arthinking  \r\n> E-mail: 1225538383@qq.com\r\n\r\n****\r\n\r\n# [Java](https://github.com/arthinking/arthinking/blob/master/Java.md \"Java\")\r\n\r\n# Mysql\r\n\r\n\r\n----------\r\n\r\n#GitHub相关资源\r\nmarkdown语法：https://github.com/guodongxiaren/test  \r\nGitHub上README写法暨GFM语法解读：http://blog.csdn.net/wqvbjhc/article/details/27349209","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/library/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/library/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h1><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><a href="http://gitbook.liuhui998.com/index.html" title="Git Community Book 中文版" target="_blank" rel="external">Git Community Book 中文版</a></p>
<p><a href="https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md" title="Git Hub秘籍" target="_blank" rel="external">Git Hub秘籍</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/MySQL/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/MySQL/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h1><h2 id="IN语句的优化"><a href="#IN语句的优化" class="headerlink" title="IN语句的优化"></a>IN语句的优化</h2><h3 id="demo-1"><a href="#demo-1" class="headerlink" title="demo 1"></a>demo 1</h3><p>慢语句  </p>
<pre><code class="SQL"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span>(<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> t_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> country)
</code></pre>
<p>优化</p>
<pre><code class="SQL"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_user t1, (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">id</span>) <span class="keyword">AS</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> country) t2 <span class="keyword">WHERE</span> t1.id = t2.id
</code></pre>
<h2 id="大表查询优化"><a href="#大表查询优化" class="headerlink" title="大表查询优化"></a>大表查询优化</h2><p>随着数据库数据的增加，查询速度会越来越慢，可以开启log_slow_queries慢查询日志，通过查看<a href="http://www.itzhai.com/access-speed-too-slow-mysql-statement-analysis.html" title="慢查询日志" target="_blank" rel="external">慢查询日志</a>找到慢语句，进行优化。  </p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="数据库中主键设计原则"><a href="#数据库中主键设计原则" class="headerlink" title="数据库中主键设计原则"></a>数据库中主键设计原则</h2>
      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/HTTP协议/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/HTTP协议/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>##HTTP协议返回码，301,302</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/8/" class="pagination-prev">Prev</a>
  
  
</nav>
      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 arthinking
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>