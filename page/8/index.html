<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 8 | arthinking | ChinSyun Pang&#39;s blog</title>
  <meta name="author" content="arthinking">
  
  <meta name="description" content="Struggle for HighPay zoom.">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:site_name" content="arthinking"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="arthinking" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">arthinking</a>
  </h1>
  <p class="site-description">ChinSyun Pang&#39;s blog</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        
  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>#Java基础知识</p>
<p>##HashMap 与 ConcurrentHashMap<br>HashMap的扩容机制，ConcurrentHashMap的原理：</p>
<blockquote>
<p><a href="HashMap的设计原理和实现分析" title="http://blog.csdn.net/luanlouis/article/details/41576373">HashMap的设计原理和实现分析</a><br>HashMap造成的死锁问题<br><a href="ConcurrentHashMap原理分析" title="http://pengtyao.iteye.com/blog/1074271">ConcurrentHashMap原理分析</a></p>
</blockquote>
<p>我们可以在单线程时使用HashMap提高效率，而多线程时用Hashtable来保证安全。</p>
<p>HashMap作为缓存导致的思索问题分析</p>
<p>##序列化的作用是，序列化id会出现哪些问题<br><a href="http://www.itzhai.com/javascript-design-patterns-notes-combined-mode.html#2、外观模式：" title="外观模式" target="_blank" rel="external">外观模式</a>的例子：<a href="http://www.ibm.com/developerworks/cn/java/j-lo-serial/#major3" title="Java序列化ID问题" target="_blank" rel="external">Java序列化ID问题</a><br>这是一个关于客户端程序版本升级的例子，当服务器端的对象改动，重新生成了id，这个时候客户端解析旧的对象就会失败，这个时候，必须重新从服务器端获取最新的对象序列化文件。</p>
<p>##JDK常用库，JDK源代码</p>
<p>###Java IO类库结构图，和所用到的设计模式</p>
<p>##NIO</p>
<p>###阻塞后的通知机制</p>
<p>##RuntimeException与CheckedException<br><strong>checked exception</strong><br>checked exception是从java.lang.Exception类衍生出来的；<br>runtime exception是从java.lang.RuntimeException 或java.lang.Error类衍生出来的，RuntimeException又继承自Exception；<br>checked exception用来指示一种调用方能够直接处理的异常情况；    </p>
<p><strong>Runtime Exception</strong><br>在定义方法时，不需要声明会抛出runtime exception，在调用方法是不需要捕获runtime exception；<br>定义方法是必须声明所有可能会抛出的checked exception，在调用方法时，必须捕获它的checked exception,或者throws出去；<br>runtime exception指示一种调用方法无法处理货恢复的程序错误；    </p>
<p>#反射 动态代理<br><a href="http://yajie.iteye.com/blog/1186522" title="看看java的反射效率" target="_blank" rel="external">看看java的反射效率</a></p>
<hr>
<p>#Java配置文件</p>
<hr>
<h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h1><h2 id="深入理解Java虚拟机笔记"><a href="#深入理解Java虚拟机笔记" class="headerlink" title="深入理解Java虚拟机笔记"></a>深入理解Java虚拟机笔记</h2><ul>
<li><a href="http://www.itzhai.com/jvm-note-introduce-java.html" title="走近Java" target="_blank" rel="external">走近Java</a></li>
<li><p><a href="http://www.itzhai.com/jvm-note-automatic-memory-management-mechanism.html" title="自动内存管理机制（Java内存区域与内存溢出异常）" target="_blank" rel="external">自动内存管理机制（Java内存区域与内存溢出异常）</a><br>  <a href="https://github.com/arthinking/java-code/blob/master/src/me/arthinking/memoryleaktest/HeapOOM.java" title="Java堆溢出" target="_blank" rel="external">Java堆溢出</a><br>  <a href="https://github.com/arthinking/java-code/tree/master/src/me/arthinking/memoryleaktest" title="more" target="_blank" rel="external">more</a><br>  新生代Minor GC的例子：<a href="https://github.com/arthinking/java-code/blob/master/src/me/arthinking/code4jvmnote/C_3_5_Minor_GC.java" title="点我" target="_blank" rel="external">点我</a></p>
<blockquote>
<ol>
<li>分配allocation4时，Eden已经被占用6MB，不够了（总共8MB），所以发生了一次Minor GC；  </li>
<li>GC期间发现已有的3X2MB大小对象无法全部放入Survivor空间,所以只好通过<a href="http://www.itzhai.com/jvm-note-automatic-memory-management-mechanism-2-html.html#6.5、空间分配担保" title="分配担保机制" target="_blank" rel="external">分配担保机制</a>提前转移到老年代去了；  </li>
<li>GC结束后，4MB的allocation4对象被分配到Eden中，Survivor空闲，老年代占用6MB    </li>
</ol>
</blockquote>
</li>
<li><p><a href="http://www.itzhai.com/jvm-note-automatic-memory-management-mechanism-2-html.html" title="自动内存管理机制（垃圾收集器与内存分配策略）" target="_blank" rel="external">自动内存管理机制（垃圾收集器与内存分配策略）</a>    </p>
</li>
<li><a href="http://www.itzhai.com/jvm-note-automatic-memory-management-mechanism-3.html" title="自动内存管理机制（虚拟机性能监控与故障处理工具）" target="_blank" rel="external">自动内存管理机制（虚拟机性能监控与故障处理工具）</a>     </li>
</ul>
<p>下面是Java中的内存泄露分析的例子：<a href="http://www.itzhai.com/java-memory-leak-analyze.html" title="Java中内存泄露的分析" target="_blank" rel="external">Java中内存泄露的分析</a> </p>
<ul>
<li><a href="http://www.itzhai.com/jvm-note-automatic-memory-management-mechanism-4.html" title="自动内存管理机制（调优案例分析与实战）" target="_blank" rel="external">自动内存管理机制（调优案例分析与实战）</a> </li>
<li><a href="http://www.itzhai.com/the-class-file-structure.html" title="虚拟机执行子系统（类文件结构）" target="_blank" rel="external">虚拟机执行子系统（类文件结构）</a>     </li>
</ul>
<p>对于同步指令monitorenter和monitorexit，编译器会自动产生一个异常处理器，这个异常处理器声明可以处理所有的异常，它的目的就是用来执行monitorexit指令。</p>
<ul>
<li><a href="http://www.itzhai.com/the-class-file-structure.html" title="虚拟机执行子系统（虚拟机类加载机制）" target="_blank" rel="external">虚拟机执行子系统（虚拟机类加载机制）</a>     </li>
</ul>
<p>加载 -&gt; (验证 -&gt; 准备 -&gt; <code>解析</code>) -&gt; 初始化 -&gt; 使用 -&gt; 卸载<br>其中解析阶段可以在初始化阶段之后再开始，以便支持运行时绑定（动态绑定或晚期绑定）。</p>
<p>JVM中严格规定有且只有一下五中情况必须对类进行“初始化”：<a href="http://" target="_blank" rel="external">detail</a>(加载、验证、准备自然需要在此之前开始)    </p>
<p>这5种场景称为对一个类的主动引用，其余的称为被动引用，不会触发初始化，以下是几个例子：</p>
<blockquote>
<p>通过子类引用父类的静态字段，不会导致子类初始化</p>
<p>通过数组定义来引用类，不会触发此类的初始化    </p>
<p>调用一个类中的常量，不会触发常量的类的初始化    </p>
</blockquote>
<p>###JVM内存模型与GC回收机制</p>
<p>###JVM调优和常用工具</p>
<p><strong>如何dump出当前线程的状态</strong><br>使用<a href="http://www.blogjava.net/jzone/articles/303979.html" title="jstack pid" target="_blank" rel="external">jstack pid</a>进行分析，<a href="http://segmentfault.com/blog/yexiaobai/1190000000615690" title="Thread Dumps的分析" target="_blank" rel="external">Thread Dumps的分析</a>    </p>
<p><strong><em>线程的状态：</em></strong><br><code>Runnable</code>：<br><code>Wait oncondition</code>：<br><code>Waiting for monitor entry</code>：<br><code>in Object.wait()</code>：        </p>
<p><strong><em>案例</em></strong>：<code>死锁</code> &amp; <code>热锁</code><br>Java5中加强了堆思索的监测线程Dump中科院直接报告出Java级别的思索。</p>
<blockquote>
<p>如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中发现了这个情况，应该审查源码，改进程序。(引用)</p>
</blockquote>
<p><strong>JVM调优相关经验</strong></p>
<p>##ClassLoader结构，是否可以自定义一个String类<br>说说ClassLoader的双亲代理机制</p>
<p>##修改类加载器实现热部署<br><a href="http://www.ibm.com/developerworks/cn/java/j-lo-hotdeploy/index.html" title="ASM修改字节码文件" target="_blank" rel="external">ASM修改字节码文件</a>的流程是一个职责链模式，可以通过ASM修改字节码文件的方式，让每次实例化的时候都是用最新版本的Class文件生成实例，从而达到热部署，但是PermGen space还是不可避免。另外，这种方法仅仅是让新实例化的对象是用新的逻辑；<br><a href="http://my.oschina.net/heroShane/blog/198492" title="Tomcat" target="_blank" rel="external">Tomcat</a>中的热部署实现。</p>
<hr>
<p>#框架源码相关</p>
<p>##并发框架<br>多线程并发用过哪些</p>
<p>##Spring</p>
<p>##OSGi框架</p>
<p>###如何在一个bundle中加载另一个bundle的Class对象</p>
<hr>
<p>#Java Web</p>
<p>##Servlet与Filter的作用，原理，配置</p>
<p>##Session共享机制</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/spring/2015010601-接口设计原则/"><span>接口设计原则</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/spring/2015010601-接口设计原则/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>接口尽量设计的单一职责，会方便代码的扩展和维护。</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/设计模式/">设计模式</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120701_JVM笔记 - 高效并发（Java内存模型与线程）/"><span>JVM笔记 - 高效并发（Java内存模型与线程）</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120701_JVM笔记 - 高效并发（Java内存模型与线程）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#1、概述</p>
<p>#2、硬件的效率与一致性<br>基于告诉缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来了更高的复杂度，因为它引入了一个新的问题：缓存一致性。</p>
<p>处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的。</p>
<p>#3、Java内存模型<br>线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行。</p>
<p>##3.1、主内存与工作内存</p>
<p>##3.2、内存间交互操作</p>
<p>##3.3、对于volatile型变量的特殊规则</p>
<p>当一个变量定义为volitile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性。</p>
<hr>
<p>volitile变量在各个线程中是一致的，并不能得出基于volitile变量的运算在并发下是安全的这个结论。</p>
<p>volatile变量的运算在并发下一样是不安全的。</p>
<p>当getstatic指令把变量的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把变量的值加大了。</p>
<p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性：</p>
<ul>
<li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程变量的值。</p>
</li>
<li><p>变量不需要与其他的状态变量共同参与不变约束。</p>
</li>
</ul>
<p>使用volatile变量的第二个语义是禁止指令重排优化。</p>
<hr>
<p>普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p>
<p>指令重排是并发编程中最容易让开发人员产生疑惑的地方，volitile关键字可以禁止指令重排序优化。</p>
<p>volatile变量读取操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要再笨的代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁第，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。</p>
<blockquote>
<p>如一个变量的修改不依赖与原值，则这个时候可以使用volatile关键字实现先行发生关系。</p>
</blockquote>
<p>##3.4、对于long和double型变量的特殊规则<br>在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编码时一般不需要把用到的long和double变量专门声明为volatile。</p>
<p>##3.5、原子性、可见性与有序性</p>
<p>###原子性<br>由Java内存模型来直接保证的原子性变量操作包括：read、load、assign、use、store和write。</p>
<p>###可见性<br>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p>
<p>除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。</p>
<p>###有序性<br>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
<p>大部分并发控制都能使用synchronized来完成。synchronized的“万能”也间接早就了它被程序员滥用的局面，越“万能”的并发控制，通常会伴随着越大的性能影响。</p>
<p>##3.6、先行发生原则<br>依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<p>下面是Java内存模型下一些“天然的”先行发生关系：</p>
<ul>
<li>程序次序规则</li>
<li>管程锁定规则</li>
<li>volatile变量规则</li>
<li>线程启动规则</li>
<li>线程终止规则</li>
<li>线程中断规则</li>
<li>对象终结规则</li>
<li>传递性</li>
</ul>
<p>#4、Java与线程</p>
<p>##4.1、线程的实现<br>Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的。</p>
<p>实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</p>
<p>###使用内核线程实现<br>由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要再用户态和内核态中来回切换。</p>
<p>###使用用户线程实现</p>
<p>###使用用户线程加轻量级进程混合实现</p>
<p>###Java线程的实现</p>
<p>##4.2、Java线程调度<br>分为协同式线程调度和抢占式线程调度。Java使用的线程调度方式就是抢占式调度。</p>
<p>线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统。</p>
<p>##4.3、状态转换</p>
<p>###以下方法会让线程陷入无限期的等待状态：</p>
<ul>
<li>没有设置Timeout参数的Object.wait()方法</li>
<li>没有设置Timeout参数的Thread.join()方法</li>
<li>LockSupport.park()方法</li>
</ul>
<p>以下方法会让线程进入限期等待状体：</p>
<ul>
<li>Thread.sleep()</li>
<li>设置了Timeout参数的Object.wait()方法</li>
<li>设置了Timeout参数的Thread.join()方法</li>
<li>LockSupport.parkNanos()方法</li>
<li>LockSupport.parkUntil()方法</li>
</ul>
<p>#5、本章小结</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120601_JVM笔记 - 程序编译与代码优化（晚期（运行期）优化）/"><span>JVM笔记 - 程序编译与代码优化（晚期（运行期）优化）</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120601_JVM笔记 - 程序编译与代码优化（晚期（运行期）优化）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#1、概述<br>即时编译器并不是虚拟机必需的部分。</p>
<p>本章提及的编译器、即时编译器都是指 HotSpot 虚拟机内的即时编译器，虚拟机也是特指 HotSpot 虚拟机。</p>
<p>#2、HotSpot虚拟机内的即时编译器</p>
<p>##2.1、解释器与编译器<br>HotSpot 虚拟机中内置了两个即时编译器，分别称为 Client Compiler 和 Server   Compiler。</p>
<p>HotSpot 虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用”- client” 或”- server” 参数去强制指定虚拟机运行在 Client 模式或 Server 模式。</p>
<p>参数”- Xint” 强制虚拟机运行于“解释模式”（ Interpreted   Mode）。</p>
<p>参数”- Xcomp” 强制虚拟机运行于“编译模式”（ Compiled   Mode），这时将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。</p>
<p>为了在程序启动响应速度与运行效率之间达到最佳平衡， HotSpot 虚拟机还会逐渐启用分层编译（ Tiered Compilation）[ 4] 的策略。</p>
<p>实施分层编译后， Client   Compiler 和 Server   Compiler 将会同时工作，许多代码都可能会被多次编译，用 Client   Compiler 获取更高的编译速度，用 Server   Compiler 来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。</p>
<p>##2.2、编译对象与触发条件<br>“热点代码”有两类，即：被多次调用的方法。被多次执行的循环体。</p>
<p>这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为栈上替换（ On   Stack   Replacement， 简称为 OSR 编译，即方法栈帧还在栈上，方法就被替换了）。</p>
<p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测。</p>
<p>目前主要的热点探测判定方式有两种：基于采样的热点探测，基于计数器的热点探测。</p>
<p>在 HotSpot 虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两类计数器：方法调用计数器（ Invocation   Counter） 和回边计数器（ Back   Edge   Counter）。</p>
<p>当计数器超过阈值溢出了，就会触发 JIT 编译。</p>
<p>当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的。</p>
<p>使用虚拟机参数- XX:- UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数。</p>
<p>使用- XX: CounterHalfLifeTime 参数设置半衰周期的时间，单位是秒。</p>
<p>回边计数器，它的作用是统计一个方法中循环体代码执行的次数。<br>建立回边计数器统计的目的就是为了触发 OSR 编译。<br>参数- XX: OnStackReplacePercentage 来间接调整回边计数器的阈值。</p>
<p>##2.3、编译过程<br>在默认设置下，无论是方法调用产生的即时编译请求，还是 OSR 编译请求，虚拟机在代码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线程中进行。</p>
<p>用户可以通过参数- XX:- BackgroundCompilation 来禁止后台编译。</p>
<p>对于 Client   Compiler 来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。</p>
<p>而 Server Compiler 则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器,也是一个充分优化过的高级编译器,几乎能达到 GNU C++编译器使用-O2参数时的优化强度。</p>
<p>##2.4、查看及分析即时编译结果</p>
<p>#3、编译优化技术</p>
<p>##3.1、优化技术概览<br>这些代码优化变换是建立在代码的某种中间表示或机器码之上，绝不是建立在Java源码之上的。</p>
<p>##3.2、公共子表达式消除</p>
<p>##3.3、数组边界检查消除<br>除了如数组边界检查优化这种尽可能把运行期检查提到编译器完成的思路之外，另外还有一种避免思路：隐式异常处理。</p>
<p>当 foo 不为空的时候,对 value 的访问是不会额外消耗一次对 foo 判空的开销的。代价就是当 foo 真的为空时,必须转入到异常处理器中恢复并抛出 NullPointException异常，这个过程必须从用户态转动内核态中处理，结束后再回到用户态，速度远比一次判空检查慢。</p>
<p>##3.4、方法内联<br>只有使用invokespecial指令调用的私有方法、实例构造器、父类方法以及使用invokestatic指令进行调用的静态方法才是在编译期进行解析的。</p>
<p>##3.5、逃逸分析<br>逃逸分析的基本行为就是分析对象动态作用域。</p>
<p>如果确定一个方法不会逃逸出方法之外，那让整个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧而销毁。在一般应用中，不会逃逸的局部对象所占用的比例很大，如果能使用栈上分配，那大量的对象就会随着方法结束而自动销毁了，垃圾手机系统的压力将会小很多。</p>
<p>同步消除</p>
<p>标量替换</p>
<p>#4、Java与C/C++的编译器对比<br>除了它们自身的API库实现得好坏之外，其余的比较就成了一场“拼编译器”和“拼输出代码质量”的游戏。</p>
<p>Java虚拟机的即时编译器与C/C++的静态优化编译器相比，可能会由于下列这些原因导致输出的本地代码有一些劣势：<br>即时编译器运行占用的是用户程序的运行时间<br>Java语言是动态的类型安全语言<br>Java语言中虽然没有virtual关键字，但是使用虚方法的频率却远远大于C/C++语言<br>Java语言是可以动态扩展的语言<br>Java语言中对象的内存分配都是在堆上进行的，只有方法中的局部变量才能在堆上分配</p>
<p>#5、本章小结</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/server/resin/resin配置/"><span>Resin配置</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/server/resin/resin配置/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#1、安装</p>
<p>##1.1、上传resin程序包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/mmt/soft</span><br><span class="line">#将resin-pro-3.1.12.tar.gz程序上传至soft目录下，解包：</span><br><span class="line">tar zxvf resin-pro-3.1.12.tar.gz</span><br><span class="line">#将解包后的程序copy至/usr/local目录下：</span><br><span class="line">cp -rf resin-pro-3.1.12 /usr/local</span><br><span class="line">#将 resin-pro-3.1.12 改名为 resin</span><br><span class="line">mv /usr/local/resin-pro-3.1.12/ /usr/local/resin</span><br><span class="line">#进入/usr/local/resin/目录</span><br><span class="line">cd /usr/local/resin</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>相关资源：    </p>
<p><a href="http://blog.csdn.net/tegwy/article/details/8870873" title="ubuntu 编译并安装resin3.1.12+nginx1.2.6" target="_blank" rel="external">ubuntu 编译并安装resin3.1.12+nginx1.2.6</a></p>
</blockquote>
<p>##1.2、安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-java-home=/usr/lib/jvm/java/jdk1.6.0_26</span><br><span class="line">#启动resin，看是否安装成功</span><br><span class="line">/usr/local/resin/bin/httpd.sh start</span><br><span class="line">#如果能正常显示页面则表示安装成功，现在可以停止并设置相关配置文件了。</span><br><span class="line">/usr/local/resin/bin/httpd.sh stop</span><br></pre></td></tr></table></figure></p>
<p>#2、配置</p>
<p>##JVM参数设置</p>
<p>在resin/conf/resin.conf中的<jvm-arg>标签中进行配置，这将是启动JVM的初始化参数。</jvm-arg></p>
<p>具体的参数机器作用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- - JVM 参数设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Xms512 m<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jvm 最小内存，也是启动 resin后的默认内存分配值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Xmx512 m<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span> <span class="comment">&lt;!-- make ms=mx to reduce GC times --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jvm最大内存，当内存使用超过 Xms分配的值之后会自动向这个最大值提升，一般配置成最大最小值相等，理论上能够降低 GC 垃圾收集的时间，可按实际进行配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Xmn86m<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--内存分配增量，当内存需求超过 Xms值之后进行第一次分配请求的内存值，一般为 Xmx的 1/3-1/4 ；开始时候可以先屏蔽，当应用出现OutOfMemory的时候再打开也可以--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-XX:MaxNewSize=256m<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-XX:PermSize=128m<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-XX:MaxPermSize=256m<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以上三项是为了减少 OutOfMemory 而配置的，</span><br><span class="line">是每个java编译执行的时候最多能一次申请 jvm 内存空间的值，</span><br><span class="line">以上默认配置基本够用，但依然出OutOfMemory 的时候可以适当调大，</span><br><span class="line">但不能超越 Xmx的值；</span><br><span class="line">开始时候可以先屏蔽，当应用出现 OutOfMemory的时候再打开也可以--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Xss256k<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span> <span class="comment">&lt;!-- jvm Stack config --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Djava.awt.headless=true<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span> <span class="comment">&lt;!--允许使用验证码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Djava.net.preferIPv4Stack=true<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span> <span class="comment">&lt;!-- disable IPv6 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Doracle.jdbc.V8Compatible=true<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span><span class="comment">&lt;!--针对 oracle10的兼容配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">watchdog-arg</span>&gt;</span>-Dcom.sun.management.jmxremote<span class="tag">&lt;/<span class="name">watchdog-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 强制 resin 强制重启时的最小空闲内存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memory-free-min</span>&gt;</span>2M<span class="tag">&lt;/<span class="name">memory-free-min</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最大线程数量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thread-max</span>&gt;</span>256<span class="tag">&lt;/<span class="name">thread-max</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 套接字等待时间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">socket-timeout</span>&gt;</span>65s<span class="tag">&lt;/<span class="name">socket-timeout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置 keepalive --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keepalive-max</span>&gt;</span>128<span class="tag">&lt;/<span class="name">keepalive-max</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keepalive-timeout</span>&gt;</span>15s<span class="tag">&lt;/<span class="name">keepalive-timeout</span>&gt;</span></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">**日常遇到的OOM和频繁发生GC 情况分析**</span><br><span class="line"></span><br><span class="line">* java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">heap 空间不足，可能是 -Xmx 配得过大，或者系统内存不足或泄漏</span><br><span class="line"></span><br><span class="line">* java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">持久代内存不足，存在大量系统类被加载或 jpa 等架构频繁使用，需要增加 Perm的内存配置</span><br><span class="line"></span><br><span class="line">* java.lang.OutOfMemoryError:unable to create native thread</span><br><span class="line"></span><br><span class="line">* 空闲内存不足以建立新的线程，减少 max-threads 的配置，增加空闲内存数量</span><br><span class="line"></span><br><span class="line">在实际的生产环境中，以下三个东西经常用到，所以在这里提一下，也算是简单的优化。</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line"><span class="tag">&lt;<span class="name">thread-max</span>&gt;</span>512<span class="tag">&lt;/<span class="name">thread-max</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--最大线程数影响 resin 的系统负载能力以及 java 进程的内存占用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keepalive-max</span>&gt;</span>128<span class="tag">&lt;/<span class="name">keepalive-max</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--keepalive 的最大数量，对网络性能有影响--&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>###JVM调优相关：    </p>
<ul>
<li><a href="http://blog.csdn.net/tyrone1979/article/details/1274458" title="JVM调优" target="_blank" rel="external">JVM调优</a>    </li>
<li><a href="http://www.opendigest.org/article.php/450" title="resin优化经验" target="_blank" rel="external">resin优化经验</a>    </li>
<li><a href="http://www.caucho.com/resin-3.0/performance/jvm-tuning.xtp#garbage-collection" title="resin" target="_blank" rel="external">resin</a>    </li>
<li>js/html/css/jpg/gif 等静态文件由 nginx 提供服务，剩下的由nginx以upstream方式代理到后端resin处理，以减少resin 提供这些静态文件访问的性能问题。</li>
</ul>
<p>Resin 及 jvm 优化，是一项基于提供服务的应用上进行一段相对长时间的测试进行，由于每个项目都有其自身特点，只有根据这些特点来进行优化，才能把该项目配置得更好 ，不可能硬套到其它项目上 。</p>
<p><strong>测试线程并发量</strong>    </p>
<p>先将resin.conf文件中的thread-min，thread-max，thread-keepalive三个参数设置的比较大，分别写上，1000，3000，1000，当然这是根据你的机器情况和可能同时访问的数量决定的，如果你的网站访问量很大的，应该再适当放大。</p>
<p>然后观察任务管理器中的java线程变化情况，看看到底是线程达到多大的时候，java进程当掉的。我的是在379左右当掉。</p>
<p>然后将thread-min，thread-max，thread-keepalive分别写为150，400，300；也就是将当掉的时候的最大值稍微放大点，作为thread-max的值，因为该系统一般不会超过这个值。然后其他两个参数根据情况设置一下。</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/应用服务器/">应用服务器</a>, <a href="/categories/应用服务器/Resin/">Resin</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/Resin/">Resin</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120501_JVM笔记 - 程序编译与代码优化（早期（编译器）优化）/"><span>JVM笔记 - 程序编译与代码优化（早期（编译器）优化）</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120501_JVM笔记 - 程序编译与代码优化（早期（编译器）优化）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#1、概述<br>Java语言的“编译期”是一段不确定的操作过程，可能是：    </p>
<ul>
<li>前端编译器（编译器的前端）把Java文件转换为class文件；Sun 的 Javac、 Eclipse   JDT 中的增量式编译器（ ECJ）[ 1]。</li>
<li>后端编译器（JIT编译期 Just in time compiler）把字节码变成机器码；JIT 编译器： HotSpot   VM 的 C1、 C2 编译器。</li>
<li>静态编译器（AOT编译器 ahead of time compiler）直接把Java编译成本地机器代码；</li>
<li>AOT 编译器： GNU   Compiler   for   the   Java（ GCJ）[ 2]、 Excelsior JET[ 3]。</li>
</ul>
<p>本章讨论第一类编译过程。</p>
<p>Javac 这类编译器对代码的运行效率几乎没有任何优化措施（在 JDK   1. 3 之后， Javac 的- O 优化参数就不再有意义）。虚拟机设计团队把对性能的优化集中到了后端的即时编译器中。</p>
<p>#2、Javac编译器<br>它本身就是一个由 Java 语言编写的程序，这为纯 Java 的程序员了解它的编译过程带来了很大的便利。</p>
<p>##2.1、Javac的源码与调试</p>
<p>##2.2、解析与填充符号表</p>
<p>##2.3、注解处理器<br>提供了一组插入式注解处理器的标准 API 在编译期间对注解进行处理。</p>
<p>有了编译器注解处理的标准 API 后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。</p>
<p>在 Javac 源码中，插入式注解处理器的初始化过程是在 initPorcessAnnotations() 方法中完成的，而它的执行过程则是在processAnnotations() 方法中完成的。</p>
<p>##2.4、语义分析与字节码生成<br>编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。</p>
<p>是否合乎语义逻辑必须限定在具体的语言与具体的上下文环境之中才有意义。</p>
<blockquote>
<p>标注检查 Javac 的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤。</p>
</blockquote>
<p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠。</p>
<p>由于编译期间进行了常量折叠，所以在代码里面定义” a= 1+ 2” 比起直接定义” a= 3”， 并不会增加程序运行期哪怕仅仅一个 CPU 指令的运算量。</p>
<blockquote>
<p>数据及控制流分析</p>
</blockquote>
<p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。</p>
<p>将局部变量声明为 final， 对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有 CONSTANT<em> Fieldref</em> info 的符号引用，自然就没有访问标志（ Access_ Flags） 的信息。</p>
<blockquote>
<p>解语法糖</p>
</blockquote>
<p>在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。</p>
<p>解语法糖的过程由 desugar() 方法触发。</p>
<blockquote>
<p>字节码生成</p>
</blockquote>
<p>字节码生成是 Javac 编译过程的最后一个阶段</p>
<p>把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。例如，前面章节中多次提到的实例构造器＜ init ＞()方法和类构造器＜ clinit ＞()方法就是在这个阶段添加到语法树之中的</p>
<p>还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为 StringBuffer 或 StringBuilder。</p>
<p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给 com. sun. tools. javac. jvm. ClassWriter 类，由这个类的 writeClass() 方法输出字节码，生成最终的 Class 文件，到此为止整个编译过程宣告结束。</p>
<p>#3、Java语法糖的味道</p>
<p>##3.1、泛型与类型擦除<br>Java 语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（ Raw   Type， 也称为裸类型）了，并且在相应的地方插入了强制转型代码。</p>
<p>泛型擦除成相同的原生类型只是无法重载的其中一部分原因。</p>
<p>方法重载要求方法具备不同的特征签名，返回值并不包含在方法的特征签名之中，所以返回值不参与重载选择，但是在 Class 文件格式之中，只要描述符不是完全一致的两个方法就可以共存。也就是说，两个方法如果有相同的名称和特征签名，但返回值不同，那它们也是可以合法地共存于一个 Class 文件中的。</p>
<p>link</p>
<p>Signature、 LocalVariableTypeTable 等新的属性用于解决伴随泛型而来的参数类型的识别问题， Signature 是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名[ 3]， 这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。</p>
<p>由于 List ＜ String ＞和 List ＜ Integer ＞擦除后是同一个类型，我们只能添加两个并不需要实际使用到的返回值才能完成重载。</p>
<p>擦除法所谓的擦除，仅仅是对方法的 Code 属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。</p>
<p>##3.2、自动装箱、拆箱与遍历循环<br>遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现 Iterable 接口的原因。</p>
<p>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，以及它们 equals() 方法不处理数据转型的关系，笔者建议在实际编码中尽量避免这样使用自动装箱与拆箱。</p>
<p>##3.3、条件编译<br>Java 语言当然也可以进行条件编译，方法就是使用条件为常量的 if 语句。</p>
<p>#4、实战：插入式注解处理器</p>
<p>##4.1、实战目标</p>
<p>##4.2、代码实现<br>要通过注解处理器 API 实现一个编译器插件，首先需要了解这组 API 的一些基本知识。</p>
<p>在 JDK   1. 6 新增的 javax. lang. model 包中定义了 16 类 Element， 包括了 Java 代码中最常用的元素，如：“包（ PACKAGE）、 枚举（ ENUM）、 类（ CLASS）、 注解（ ANNOTATION<em> TYPE）、 接口（ INTERFACE）、 枚举值（ ENUM</em> CONSTANT）、 字段（ FIELD）、 参数（ PARAMETER）、 本地变量（ LOCAL<em> VARIABLE）、 异常（ EXCEPTION</em> PARAMETER）、 方法（ METHOD）、 构造函数（ CONSTRUCTOR）、 静态语句块（ STATIC<em> INIT， 即 static{} 块）、实例语句块（ INSTANCE</em> INIT， 即{}块）、参数化类型（ TYPE_ PARAMETER， 既泛型尖括号内的类型）和未定义的其他语法树节点（ OTHER）”。</p>
<p>##4.3、运行与测试</p>
<p>##4.4、其他应用案例<br>NameCheckProcessor 的实战例子只演示了 JSR- 269 嵌入式注解处理器 API 中的一部分功能，基于这组 API 支持的项目还有用于校验 Hibernate 标签使用正确性的 Hibernate   Validator   Annotation Processor[ 1]（ 本质上与 NameCheckProcessor 所做的事情差不多）、自动为字段生成 getter 和 setter 方法的 Project   Lombok[ 2]（ 根据已有元素生成新的语法树元素）等。</p>
<p>#5、本章小结<br>之所以把 Javac 这类将 Java 代码转变为字节码的编译器称做“前端编译器”，是因为它只完成了从程序到抽象语法树或中间字节码的生成，而在此之后，还有一组内置于虚拟机内部的“后端编译器”完成了从字节码生成本地机器码的过程，即前面多次提到的即时编译器或 JIT 编译器，这个编译器的编译速度及编译结果的优劣，是衡量虚拟机性能一个很重要的指标。</p>
<blockquote>
<p>Javac(Java在编译时)做了哪些事情</p>
<pre><code>1、解析与填充符号表；    
2、注解处理器；    
3、语义分析与字节码生成：    
    3.1、标注检查    
    3.2、数据及控制流分析    
    3.3、解语法糖    
        3.3.1、泛型与类型擦除    
        3.3.2、自动装箱、拆箱与遍历循环    
        3.3.3、条件编译    
    3.4、字节码生成
</code></pre><p>后端编译器把字节码转换成本地机器码    </p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120401_JVM笔记 - 虚拟机执行子系统（类加载及执行子系统的案例与实战）/"><span>JVM笔记 - 虚拟机执行子系统（类加载及执行子系统的案例与实战）</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120401_JVM笔记 - 虚拟机执行子系统（类加载及执行子系统的案例与实战）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#1、概述<br>能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能。</p>
<p>#2、案例分析</p>
<p>##2.1、Tomcat：正统的类加载器架构<br>主流的 Java   Web 服务器，如 Tomcat、 Jetty、 WebLogic、 WebSphere 或其他笔者没有列举的服务器，都实现了自己定义的类加载器（一般都不止一个）。因为一个功能健全的 Web 服务器，要解决如下几个问题：    </p>
<blockquote>
<p>部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以实现相互隔离。</p>
<p>部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以互相共享。</p>
<p>服务器需要尽可能地保证自身的安全不受部署的 Web 应用程序影响。</p>
<p>支持 JSP 应用的 Web 服务器，大多数都需要支持 HotSwap 功能。</p>
</blockquote>
<p>在部署 Web 应用时，单独的一个 ClassPath 就无法满足需求了，所以各种 Web 服务器都“不约而同”地提供了好几个 ClassPath 路径供用户存放第三方类库。</p>
<p>在 Tomcat 目录结构中，有 3 组目录（”<code>/common/*</code>“、”<code>/server/*</code>“ 和”<code>/shared/*</code>“） 可以存放 Java 类库，另外还可以加上 Web 应用程序自身的目录”/ WEB- INF/*”， 一共 4 组。</p>
<p><code>CommonClassLoader</code>、 <code>CatalinaClassLoader</code>、 <code>SharedClassLoader</code> 和 <code>WebappClassLoader</code> 则是 Tomcat 自己定义的类加载器，</p>
<p>###Tomcat热部署原理<br>JasperLoader 的加载范围仅仅是这个 JSP 文件所编译出来的那一个 Class， 它出现的目的就是为了被丢弃：当服务器检测到 JSP 文件被修改时，会替换掉目前的 JasperLoader 的实例，并通过再建立一个新的 Jsp 类加载器来实现 JSP 文件的 HotSwap 功能。</p>
<p>对于 Tomcat 的 6. x 版本，只有指定了 tomcat/conf/ catalina. properties 配置文件的 server.loader 和 share.loader 项后才会真正建立 CatalinaClassLoader 和 SharedClassLoader 的实例，否则会用到这两个类加载器的地方都会用 CommonClassLoader 的实例代替，而默认的配置文件中没有设置这两个 loader 项，所以 Tomcat 6.x 顺理成章地把/common、/server 和/shared 三个目录默认合并到一起变成一个/ lib 目录。</p>
<p>##2.2、OSGi：灵活的类加载器架构<br>“学习 JEE 规范，去看 JBoss 源码；学习类加载器，就去看 OSGi 源码”。</p>
<p>OSGi 在 Java 程序员中最著名的应用案例就是Eclipse IDE。</p>
<p>一个 Bundle 可以声明它所依赖的 Java   Package（ 通过 Import- Package 描述），也可以声明它允许导出发布的 Java   Package（ 通过 Export- Package 描述）。</p>
<p>一个模块里只有被 Export 过的 Package 才可能由外界访问。</p>
<p>基于 OSGi 的程序很可能（只是很可能，并不是一定会）可以实现模块级的热插拔功能，当程序升级更新或调试除错时，可以只停用、重新安装然后启用程序的其中一部分。</p>
<p>OSGi 的 Bundle 类加载器之间只有规则，没有固定的委派关系。</p>
<p>只有具体使用某个 Package 和 Class 的时候，才会根据 Package 导入导出定义来构造 Bundle 间的委派和依赖。</p>
<p>如果一个类存在于 Bundle 的类库中但是没有被 Export， 那么这个 Bundle 的类加载器能找到这个类，但不会提供给其他 Bundle 使用</p>
<p>并非所有的应用都适合采用 OSGi 作为基础架构， OSGi 在提供强大功能的同时，也引入了额外的复杂度，带来了线程死锁和内存泄漏的风险。</p>
<p>##2.3、字节码生成技术与动态代理的实现<br>javac 也是一个由 Java 语言写成的程序，它的代码存放在 OpenJDK 的 langtools/src/share/classes/com/ sun/tools/javac 目录中[ 1]。 要深入了解字节码生成，阅读 javac 的源码是个很好的途径。</p>
<p>动态代理实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。调用了 sun.misc.ProxyGenerator.generateProxyClass() 方法来完成生成字节码的动作，这个方法可以在运行时产生一个描述代理类的字节码 byte[] 数组。</p>
<p>##2.4、Retrotranslator：跨越JDK版本<br>一种名为“ Java 逆向移植”的工具（ Java Backporting Tools）应运而生， Retrotranslator[1] 是这类工具中较出色的一个。</p>
<p>编译器在程序中使用到<code>包装对象</code>的地方自动插入了很多 Integer.valueOf()、 Float.valueOf() 之类的代码；<code>变长参数</code>在编译之后就自动转化成了一个数组来完成参数传递；<code>泛型</code>的信息则在编译阶段就已经擦除掉了（但是在元数据中还保留着），相应的地方被编译器自动插入了类型转换代码[ 2]。</p>
<p>从字节码的角度来看，<code>枚举</code>仅仅是一个继承于 java. lang. Enum、 自动生成了 values() 和 valueOf() 方法的普通 Java 类而已。</p>
<p>#3、实战：自己动手实现远程执行功能</p>
<p>##3.1、目标</p>
<p>##3.2、思路</p>
<p>##3.3、实现<br>构造函数中指定为加载 HotSwapClassLoader 类的类加载器作为父类加载器，这一步是实现提交的执行代码可以访问服务端引用类库的关键。</p>
<p>##3.4、验证</p>
<p>#4、本章小结</p>
<blockquote>
<p>《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》笔记</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/JVM/">JVM</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2015/03/17/Spring源码解读笔记/"><span>Spring源码解读笔记</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/03/17/Spring源码解读笔记/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: arthinking<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: </p>
</blockquote>
<p>#Spring-core</p>
<p>##org/springframework/core/io/相关内容</p>
<p>###UrlResource.getInputStream()  #166<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResourceUtils.useCachesIfNecessary(con);</span><br></pre></td></tr></table></figure></p>
<p>设置<code>URLConnection</code>的<code>UseCaches</code>为false，主要是为了防止在Windows下jar包被锁住。</p>
<p>###AbstractFileResolvingResource<br>里面包含了JBoss vfs协议URL文件的获取。通过静态内部类 VfsResourceDelegate 进行处理的</p>
<p>###ResourceLoader<br>是一个策略接口，其 getResource(String location)方法根据传入不同的location，返回不同的Resource。其实现类是一个可以单独使用的ResourceLoader实现类，ResourceEditor也使用了这个类</p>
<p>###DefaultResourceLoader<br>ResourceLoader的默认实现，可以单独使用，ResourceEditor使用了该类，是AbstractApplicationContext的基类。</p>
<p>##说说Spring容器的加载过程<br>XmlBeanFactory通过Resource装载Spring配置信息并启动IoC容器；<br>然后通过BeanFactory#getBean(beanName)方法从IoC容器获取Bean；<br>通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时；<br>对于单实例的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean()获取Bean的时候将直接从IoC容器的缓存中获取Bean实例。</p>
<p>##Spring MVC一次执行的原理</p>
<p>##列举出5种常用的SQL语句优化方式</p>
<p>##说说两种数据库引擎的区别</p>
<p>##猿题库</p>
<p>问题<br>描述<br>回答<br>参考网址<br>举报test</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/Java/">Java</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/Spring/">Spring</a>, <a href="/tags/Spring源码/">Spring源码</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/jsoup/2014020301_项目总体结构/"><span>jsoup项目总体结构</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/jsoup/2014020301_项目总体结构/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#项目结构如下<br>先来介绍下整体的项目结构和每个类的作用</p>
<p>##1、org.jsoup.helper<br>这个包里面包含了jsoup的辅助类</p>
<p>###1.1、DataUtils<br>处理数据的静态辅助类，主要用来把输入流转换为Document对象。</p>
<p>###1.2、DescendableLinkedList<br>实现一个从后往前遍历的迭代器，并兼容一些JDK 1.5中不支持的JDK 1.6提供的LinkedList方法。里面主要实现一个DescendingIterator继承了Iterator实现倒序遍历的功能的。</p>
<p>通过使用DescendableLinkedList执行如下的代码，将会输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure></p>
<p>与默认实现的迭代器输出相反的顺序了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DescendableLinkedList&lt;String&gt; list = <span class="keyword">new</span> DescendableLinkedList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator =list.descendingIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###1.3、HttpConnection<br>Connection的实现类，Connection提供了方便的接口，用于从网络抓取内容，并解析成Document对象。可以这样获取到一个Connection对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jsoup.Jsoup.connect(String)</span><br></pre></td></tr></table></figure></p>
<p>Connections包含了Connection.Request和Connection.Response，请求的配置可以通过userAgent(String)方法进行，或者在Connection.Request里面进行配置。</p>
<p>###1.4、StringUtil<br>功能很少的String辅助类，专门为jsoup设计的</p>
<p>###1.5、Validate<br>为jsoup而设计的简单的验证方法类，里面校验参数的时候使用了IllegalArgumentException（RuntimeException），不需要强制捕获，表示该错误为不可预知的异常，无需捕获，抛出该异常后，后面的代码不会继续执行，如下面的asdf不会打印出来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtil.padding(-<span class="number">1</span>);  <span class="comment">// 抛出IllegalArgumentException</span></span><br><span class="line">System.out.println(<span class="string">"asdf"</span>);</span><br></pre></td></tr></table></figure></p>
<p>##2、org.jsoup.nodes<br>HTML元素节点的相关类</p>
<p>###2.1、Attribute<br>HTML元素的一个属性对象，包括属性名和属性值。</p>
<p>###2.2、Attributes<br>一个HTML元素的属性集合</p>
<p>###2.3、Comment<br>注释元素，如 <!-- -->，继承自Node</p>
<p>###2.4、DataNode<br>一个数据节点，用于style，script标签，因为包含了css和js脚本，这些标签中的内容不能转换为文本显示，继承自Node。</p>
<p>###2.5、Document<br>一个HTML的文档对象Document，继承自Element。</p>
<p>###2.6、DocumentType<br>&lt;!DOCTYPE&gt; 节点</p>
<p>###2.7、Element<br>继承自Node，一个HTML元素，包含标签名称，属性集合，和子节点（包括文本节点和其他节点）。</p>
<p>###2.8、Entities<br>HTML实体和转义规则，这些转义对应的规则，存储在该包目录下的entities-base.properties和entities-full.properties文件里面。</p>
<p>###2.9、FormElement<br>表单元素</p>
<p>###2.10、Node<br>基本的抽象节点模型，Document，Comment等都是Node的子类。</p>
<p>###2.11、TextNode<br>一个文本节点，继承自Node。</p>
<p>###2.12、XmlDeclaration<br>一个XML声明</p>
<p>##3、org.jsoup.parser</p>
<p>###3.1、CharacterReader</p>
<p>###3.2、HtmlTreeBuilder</p>
<p>###3.3、HtmlTreeBuilderState</p>
<p>###3.4、ParseError</p>
<p>###3.5、ParseErrorList</p>
<p>###3.6、Parser</p>
<p>###3.7、Tag</p>
<p>###3.8、Token</p>
<p>###3.9、Tokeniser</p>
<p>###3.10、TokeniserState</p>
<p>###3.11、TokenQueue</p>
<p>###3.12、TreeBuilder</p>
<p>###3.13、XmlTreeBuilder</p>
<p>##4、org.jsoup.safety</p>
<p>###4.1、Cleaner</p>
<p>###4.2、Whitelist</p>
<p>##5、org.jsoup.select</p>
<p>###5.1、Collector</p>
<p>###5.2、CombiningEvaluator</p>
<p>###5.3、Elements</p>
<p>###5.4、Evaluator</p>
<p>###5.5、NodeTraversor</p>
<p>###5.6、NodeVisitor</p>
<p>###5.7、QueryParser</p>
<p>###5.8、Selector</p>
<p>###5.9、StructuralEvaluator</p>
<p>##Connection</p>
<p>##HttpStatusException</p>
<p>##Jsoup</p>
<p>##UnsupportedMimeTypeException</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/jsoup/">jsoup</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/IntelliJ-IDEA/">IntelliJ IDEA</a>, <a href="/tags/MAC/">MAC</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/2014120303_参数验证问题  AOP or  过滤器/"><span>参数验证问题  AOP or  过滤器</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/2014120303_参数验证问题  AOP or  过滤器/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-02T06:33:13.000Z">
          2016-02-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>使用Spring的AOP，之恩能够操作Spring上下文里面的对象。   </p>
<p>JSP编译成的Class文件，是切入不了的，JSP编译为Servlet，JSP编译后的类的实例又servlet容器进行管理，对应的，可以通过Servlet的过滤器进行扩展。    </p>
<p>##下面使用过滤器过滤验证参数：    </p>
<p>如页面大小，页数这些通用的参数验证，可以抽取出通用的逻辑放入到Filter中处理。    </p>
<p>对于使用Controller实现的接口，我们可以使用AOP进行拦截验证参数，而对于JSP页面，我们就只能使用Filter进行过滤验证了。    </p>
<p>##JSP请求整个处理流程如下：</p>
<ul>
<li>客户端发起HTTP请求</li>
<li>服务器端Web Server接受到请求，把请求转交给容器</li>
<li>容器获取到请求的url</li>
<li>容器根据web.xml中配置的filter，判断请求url是否需要执行filter</li>
<li>容器根据web.xml中的配置，找到URL对应的Servlet（如果没有找到该Servlet，直接返回404错误码到客户端，表示访问的资源不存在）</li>
<li>调用servlet的service方法处理请求（如果servlet还未装载入虚拟机，则进行加载，连接，并实例化，整个时候会调用servlet的init()方法，该方法只调用一次），分配一个线程去执行</li>
<li>如果Servlet实例需要在容器中移除的时候，则调用servlet实例的destroy方法，以便释放实例所使用的资源，并持久化数据，之后等待GC回收。</li>
</ul>
<p>##Spring Controller请求整个处理流程如下：</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/Java/">Java</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/AOP/">AOP</a>, <a href="/tags/Filter/">Filter</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/7/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/9/" class="pagination-next">Next</a>
  
</nav>
      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 arthinking
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>