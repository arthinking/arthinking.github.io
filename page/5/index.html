<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 5 | arthinking | ChinSyun Pang&#39;s blog</title>
  <meta name="author" content="arthinking">
  
  <meta name="description" content="Struggle for HighPay zoom.">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:site_name" content="arthinking"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="arthinking" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">arthinking</a>
  </h1>
  <p class="site-description">ChinSyun Pang&#39;s blog</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        
  <article class="post article">

  
  
    <h3 class="article-title"><a href="/operating-system/linux/common-command/"><span>Linux common command</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/operating-system/linux/common-command/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-11T09:40:14.000Z">
          2016-02-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<h1 id="common-linux-command"><a href="#common-linux-command" class="headerlink" title="common linux command"></a>common linux command</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="_">-l</span> -r <span class="_">-e</span> <span class="string">'arthinking.github.io'</span> /Users/arthinking/Dev/informal-essay-github/* | xargs sed -i <span class="string">""</span> <span class="string">"s/arthinking.github.io/informal-essay/g"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://www.th7.cn/system.mac/201411/77742.shtml
http://blog.csdn.net/ybygjy/article/details/42305313" target="_blank" rel="external">sed在mac下使用差异</a></p>
<h1 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h1><p>Linux的scp命令可以在Linux之间复制文件和目录：</p>
<blockquote>
<p>scp [可选参数] file_source file_target</p>
</blockquote>
<p>可选参数：</p>
<ul>
<li><code>-v</code>和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误；</li>
<li><code>-C</code>使能压缩选项；</li>
<li><code>-P</code>选择端口 . 注意 -p 已经被 rcp 使用；</li>
<li><code>-4</code>强行使用<code>IPV4</code>地址；</li>
<li><code>-6</code>强行使用<code>IPV6</code>地址。</li>
</ul>
<h2 id="从本地复制到远程"><a href="#从本地复制到远程" class="headerlink" title="从本地复制到远程"></a>从本地复制到远程</h2><h3 id="复制文件："><a href="#复制文件：" class="headerlink" title="复制文件："></a>复制文件：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定上传文件夹</span></span><br><span class="line">scp <span class="built_in">local</span>_file remote_username@remote_ip:remote_folder <span class="comment"># 指定上传后的文件名</span>scp <span class="built_in">local</span>_file remote_username@remote_ip:remote_file </span><br><span class="line"><span class="comment"># 以下两个不指定远程服务器的登录名</span>scp <span class="built_in">local</span>_file remote_ip:remote_folder scp <span class="built_in">local</span>_file remote_ip:remote_file</span><br></pre></td></tr></table></figure>
<h3 id="复制目录"><a href="#复制目录" class="headerlink" title="复制目录"></a>复制目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r <span class="built_in">local</span>_folder remote_username@remote_ip:remote_folder scp -r <span class="built_in">local</span>_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure>
<p>会在<code>remote_folder</code>下面创建<code>local_folder</code>文件夹</p>
<h2 id="从远程复制到本地"><a href="#从远程复制到本地" class="headerlink" title="从远程复制到本地"></a>从远程复制到本地</h2><p>只要将从本地复制到远程的命令的后2个参数调换顺序即可。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>从远程下载文件到本地</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp root@182.92.6.82:/home/guitargg.gz ~/Downloads/</span><br></pre></td></tr></table></figure>
<p>把本金文件传递到另一台主机上面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/Downloads/guitargg.gz root@182.92.6.82:/home/</span><br></pre></td></tr></table></figure>
<h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><p>解压：<br>tar -zxvf /usr/local/test.tar.gz<br>tar -zxvf 压缩文件名.tar.gz -C /usr/local/maven</p>
<p>01-.tar格式<br>解包：[＊＊＊＊＊＊＊]$ tar xvf FileName.tar<br>打包：[＊＊＊＊＊＊＊]$ tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）</p>
<p>02-.gz格式<br>解压1：[＊＊＊＊＊＊＊]$ gunzip FileName.gz<br>解压2：[＊＊＊＊＊＊＊]$ gzip -d FileName.gz<br>压 缩：[＊＊＊＊＊＊＊]$ gzip FileName</p>
<p>03-.tar.gz格式<br>解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tar.gz<br>压缩：[＊＊＊＊＊＊＊]$ tar zcvf FileName.tar.gz DirName</p>
<p>04-.bz2格式<br>解压1：[＊＊＊＊＊＊＊]$ bzip2 -d FileName.bz2<br>解压2：[＊＊＊＊＊＊＊]$ bunzip2 FileName.bz2<br>压 缩： [＊＊＊＊＊＊＊]$ bzip2 -z FileName</p>
<p>05-.tar.bz2格式<br>解压：[＊＊＊＊＊＊＊]$ tar jxvf FileName.tar.bz2<br>压缩：[＊＊＊＊＊＊＊]$ tar jcvf FileName.tar.bz2 DirName</p>
<p>06-.bz格式<br>解压1：[＊＊＊＊＊＊＊]$ bzip2 -d FileName.bz<br>解压2：[＊＊＊＊＊＊＊]$ bunzip2 FileName.bz</p>
<p>07-.tar.bz格式<br>解压：[＊＊＊＊＊＊＊]$ tar jxvf FileName.tar.bz</p>
<p>08-.Z格式<br>解压：[＊＊＊＊＊＊＊]$ uncompress FileName.Z<br>压缩：[＊＊＊＊＊＊＊]$ compress FileName</p>
<p>09-.tar.Z格式<br>解压：[＊＊＊＊＊＊＊]$ tar Zxvf FileName.tar.Z<br>压缩：[＊＊＊＊＊＊＊]$ tar Zcvf FileName.tar.Z DirName</p>
<p>10-.tgz格式<br>解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tgz</p>
<p>11-.tar.tgz格式<br>解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tar.tgz<br>压缩：[＊＊＊＊＊＊＊]$ tar zcvf FileName.tar.tgz FileName</p>
<p>12-.zip格式<br>解压：[＊＊＊＊＊＊＊]$ unzip FileName.zip<br>压缩：[＊＊＊＊＊＊＊]$ zip FileName.zip DirName</p>
<p>13-.lha格式<br>解压：[＊＊＊＊＊＊＊]$ lha -e FileName.lha<br>压缩：[＊＊＊＊＊＊＊]$ lha -a FileName.lha FileName</p>
<p>14-.rar格式<br>解压：[＊＊＊＊＊＊＊]$ rar a FileName.rar<br>压缩：[＊＊＊＊＊＊＊]$ rar e FileName.rar<br>rar请到：<a href="http://www.rarsoft.com/download.htm" target="_blank" rel="external">http://www.rarsoft.com/download.htm</a> 下载！<br>解压后请将rar_static拷贝到/usr/bin目录（其他由$PATH环境变量<br>指定的目录也行）：[＊＊＊＊＊＊＊]$ cp rar_static /usr/bin/rar</p>
<h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p>复制并且覆盖目标文件的文件<br>cp -r -f /webapp/* /dist/</p>
<h1 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h1><p>查看端口占用</p>
<p>lsof -i tcp:port</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/Linux/">Linux</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/spring/2014122403-spring-context/"><span>Spring context</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/spring/2014122403-spring-context/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-11T09:40:14.000Z">
          2016-02-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>Context 在 Spring 的 org.springframework.context 包下，前面已经讲解了 Context 组件在 Spring 中的作用，他实际上就是给 Spring 提供一个运行时的环境，用以保存各个对象的状态。下面看一下这个环境是如何构建的。</p>
<p>ApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了 Context 的功能。下面是 Context 的类结构图：</p>
<p><strong>Context相关的类结构图</strong></p>
<p><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2014/12/20141224-spring005.png" alt="">    </p>
<p>从上图中可以看出 ApplicationContext 继承了 BeanFactory，这也说明了 Spring 容器中运行的主体对象是 Bean，另外 ApplicationContext 继承了 ResourceLoader 接口，使得 ApplicationContext 可以访问到任何外部资源，这将在 Core 中详细说明。</p>
<p>###ApplicationContext 的子类主要包含两个方面：</p>
<ul>
<li>ConfigurableApplicationContext 表示该 Context 是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext 类。</li>
<li>WebApplicationContext 顾名思义，就是为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。<br>再往下分就是按照构建 Context 的文件类型，接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。</li>
</ul>
<p>###总体来说 ApplicationContext 必须要完成以下几件事：    </p>
<ul>
<li>标识一个应用环境</li>
<li>利用 BeanFactory 创建 Bean 对象</li>
<li>保存对象关系表</li>
<li>能够捕获各种事件</li>
<li>Context 作为 Spring 的 Ioc 容器，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。</li>
</ul>
<blockquote>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/" title="Spring 框架的设计理念与设计模式分析" target="_blank" rel="external">Spring 框架的设计理念与设计模式分析</a> </p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/Java/">Java</a>, <a href="/categories/Java/Spring/">Spring</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/README/"><span></span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/README/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-11T09:40:14.000Z">
          2016-02-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="arthinking的技术总结"><a href="#arthinking的技术总结" class="headerlink" title="arthinking的技术总结"></a>arthinking的技术总结</h2><blockquote>
<p>Author: arthinking<br>E-mail: 1225538383@qq.com</p>
</blockquote>
<hr>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a><a href="https://github.com/arthinking/arthinking/blob/master/Java.md" title="Java" target="_blank" rel="external">Java</a></h1><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><hr>
<p>#GitHub相关资源<br>markdown语法：<a href="https://github.com/guodongxiaren/test" target="_blank" rel="external">https://github.com/guodongxiaren/test</a><br>GitHub上README写法暨GFM语法解读：<a href="http://blog.csdn.net/wqvbjhc/article/details/27349209" target="_blank" rel="external">http://blog.csdn.net/wqvbjhc/article/details/27349209</a></p>
<p>图片格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-02.png</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/spring/2014122404-spring-core/"><span>Spring core</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/spring/2014122404-spring-core/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-11T09:40:14.000Z">
          2016-02-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>Core 组件作为 Spring 的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源的访问方式。这种把所有资源都抽象成一个接口的方式很值得在以后的设计中拿来学习。下面就重要看一下这个部分在 Spring 的作用。</p>
<p><strong>Resource相关的类结构图：</strong><br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2014/12/20141224-spring006.png" alt=""> </p>
<p>从上图可以看出 Resource 接口封装了各种可能的资源类型，也就是对使用者来说屏蔽了文件类型的不同。对资源的提供者来说，如何把资源包装起来交给其他人用这也是一个问题，我们看到 Resource 接口继承了 InputStreamSource 接口，这个接口中有个 getInputStream 方法，返回的是 InputStream 类。这样所有的资源都被可以通过 InputStream 这个类来获取，所以也屏蔽了资源的提供者。另外还有一个问题就是加载资源的问题，也就是资源的加载者要统一，从上图中可以看出这个任务是由 ResourceLoader 接口完成，他屏蔽了所有的资源加载者的差异，只需要实现这个接口就可以加载所有的资源，他的默认实现是 DefaultResourceLoader。<br>下面看一下 Context 和 Resource 是如何建立关系的？首先看一下他们的类关系图：</p>
<p><strong>Context和Resource的类关系图</strong><br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2014/12/20141224-spring007.png" alt=""> </p>
<h3 id="如何创建BeanFactory工厂"><a href="#如何创建BeanFactory工厂" class="headerlink" title="如何创建BeanFactory工厂"></a>如何创建BeanFactory工厂</h3><p>正如图 2 描述的那样，Ioc 容器实际上就是 Context 组件结合其他两个组件共同构建了一个 Bean 关系网，如何构建这个关系网？构建的入口就在 AbstractApplicationContext 类的 refresh 方法中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123; </span><br><span class="line">    synchronized (this.startupShutdownMonitor) &#123; </span><br><span class="line">        // Prepare this context for refreshing. </span><br><span class="line">        // 创建和配置BeanFactory</span><br><span class="line">        prepareRefresh(); </span><br><span class="line">        // Tell the subclass to refresh the internal bean factory. </span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); </span><br><span class="line">        // Prepare the bean factory for use in this context. </span><br><span class="line">        prepareBeanFactory(beanFactory); </span><br><span class="line">        try &#123; </span><br><span class="line">            // Allows post-processing of the bean factory in context subclasses. </span><br><span class="line">            postProcessBeanFactory(beanFactory); </span><br><span class="line">            // Invoke factory processors registered as beans in the context. </span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory); </span><br><span class="line">            // Register bean processors that intercept bean creation. </span><br><span class="line">            registerBeanPostProcessors(beanFactory); </span><br><span class="line">            // Initialize message source for this context. </span><br><span class="line">            initMessageSource(); </span><br><span class="line">            // Initialize event multicaster for this context. </span><br><span class="line">            initApplicationEventMulticaster(); </span><br><span class="line">            // Initialize other special beans in specific context subclasses. </span><br><span class="line">            onRefresh(); </span><br><span class="line">            // Check for listener beans and register them. </span><br><span class="line">            registerListeners(); </span><br><span class="line">            // Instantiate all remaining (non-lazy-init) singletons. </span><br><span class="line">            finishBeanFactoryInitialization(beanFactory); </span><br><span class="line">            // Last step: publish corresponding event. </span><br><span class="line">            finishRefresh(); </span><br><span class="line">        &#125; </span><br><span class="line">        catch (BeansException ex) &#123; </span><br><span class="line">            // Destroy already created singletons to avoid dangling resources. </span><br><span class="line">            destroyBeans(); </span><br><span class="line">            // Reset &apos;active&apos; flag. </span><br><span class="line">            cancelRefresh(ex); </span><br><span class="line">            // Propagate exception to caller. </span><br><span class="line">            throw ex; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法就是构建整个 Ioc 容器过程的完整的代码，了解了里面的每一行代码基本上就了解大部分 Spring 的原理和功能了。</p>
<p>这段代码主要包含这样几个步骤：    </p>
<ul>
<li>构建 BeanFactory，以便于产生所需的“演员”</li>
<li>注册可能感兴趣的事件</li>
<li>创建 Bean 实例对象</li>
<li>触发被监听的事件</li>
</ul>
<p>实现AbstractApplicationContext的refreshBeanFactory的refreshBeanFactory()子类的方法，可更新的子类AbstractRefreshableApplicationContext：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected final void refreshBeanFactory() throws BeansException &#123; </span><br><span class="line">    if (hasBeanFactory()) &#123; </span><br><span class="line">        destroyBeans(); </span><br><span class="line">        closeBeanFactory(); </span><br><span class="line">    &#125; </span><br><span class="line">    try &#123; </span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory(); </span><br><span class="line">        beanFactory.setSerializationId(getId()); </span><br><span class="line">        customizeBeanFactory(beanFactory); </span><br><span class="line">        loadBeanDefinitions(beanFactory); </span><br><span class="line">        synchronized (this.beanFactoryMonitor) &#123; </span><br><span class="line">            this.beanFactory = beanFactory; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    catch (IOException ex) &#123; </span><br><span class="line">        throw new ApplicationContextException(</span><br><span class="line">			&quot;I/O error parsing bean definition source for &quot; </span><br><span class="line">			+ getDisplayName(), ex); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BeanFactory 的原始对象是 DefaultListableBeanFactory，这个非常关键，因为他设计到后面对这个对象的多种操作，下面看一下这个类的继承层次类图：</p>
<blockquote>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/" title="Spring 框架的设计理念与设计模式分析" target="_blank" rel="external">Spring 框架的设计理念与设计模式分析</a> </p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/Java/">Java</a>, <a href="/categories/Java/Spring/">Spring</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/cache/memcached/Memcached配置使用与监控/"><span>Memcached配置使用与监控</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/cache/memcached/Memcached配置使用与监控/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-11T09:40:14.000Z">
          2016-02-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#1、配置</p>
<p>##1.1、安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install memcached</span><br></pre></td></tr></table></figure></p>
<p>##1.2、启动</p>
<blockquote>
<p>Memcached的基本设置：</p>
<p>-p 监听的端口<br>-l 连接的IP地址, 默认是本机<br>-d start 启动memcached服务<br>-d restart 重起memcached服务<br>-d stop|shutdown 关闭正在运行的memcached服务<br>-d install 安装memcached服务<br>-d uninstall 卸载memcached服务<br>-u 以的身份运行 (仅在以root运行的时候有效)<br>-m 最大内存使用，单位MB。默认64MB<br>-M 内存耗尽时返回错误，而不是删除项<br>-c 最大同时连接数，默认是1024<br>-f 块大小增长因子，默认是1.25<br>-n 最小分配空间，key+value+flags默认是48<br>-h 显示帮助<br>mixi的设置,单台:    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 每台mc服务器仅启动一个mc进程，分配1G内存</span><br><span class="line">/usr/bin/memcached -p 11211 -u nobody -m 1000 -c 512</span><br><span class="line"></span><br><span class="line"># 启动mc</span><br><span class="line">/usr/share/memcached/scripts/start-memcached</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">注意：32位的操作系统中，每个进程最多只能够使用**2G**的内存，所以需要更大的内存的时候就只能进行集群了。（用同一台服务器进行集群，TCP连接数就会成倍增加，x86_64的操作系统可以分配超过2G的内存）；</span><br><span class="line"></span><br><span class="line">mc进程的实际内存分配量要比置顶的内存要大一些，所以如果置顶分配的内存太大了，有可能导致内存交换（swap）。</span><br><span class="line"></span><br><span class="line">#2、集群配置</span><br><span class="line">通过magent能够让缓存写入到多个不同的memcached里面</span><br><span class="line"></span><br><span class="line">##2.1、安装使用magent</span><br><span class="line">###2.1.1、编译安装libevent</span><br><span class="line">```shell</span><br><span class="line">wget http://monkey.org/~provos/libevent-1.4.9-stable.tar.gz</span><br><span class="line">tar zxvf libevent-1.4.9-stable.tar.gz</span><br><span class="line">cd libevent-1.4.9-stable/</span><br><span class="line">./configure --prefix=/usr</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cd ../</span><br></pre></td></tr></table></figure>
<p>###2.1.2、编译安装Memcached：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://danga.com/memcached/dist/memcached-1.2.6.tar.gz</span><br><span class="line">tar zxvf memcached-1.2.6.tar.gz</span><br><span class="line">cd memcached-1.2.6/</span><br><span class="line">./configure --with-libevent=/usr</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cd ../</span><br></pre></td></tr></table></figure></p>
<p>###2.1.3、编译安装magent：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir magent</span><br><span class="line">cd magent/</span><br><span class="line">wget http://memagent.googlecode.com/files/magent-0.5.tar.gz</span><br><span class="line">tar zxvf magent-0.5.tar.gz</span><br><span class="line">/sbin/ldconfig</span><br><span class="line">sed -i &quot;s#LIBS = -levent#LIBS = -levent -lm#g&quot; Makefile</span><br><span class="line">make</span><br><span class="line">cp magent /usr/bin/magent</span><br><span class="line">cd ../</span><br></pre></td></tr></table></figure></p>
<p>###2.1.4、集群配置<br>集群两台服务器，实现缓存备份。<br>高可用网络架构：<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2014/12/20141217-mc001.png" alt=""></p>
<p><strong>启动两个mc进程，端口分别为11211,11212</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memcached -m 1 -u root -d -l 127.0.0.1 -p 11211</span><br><span class="line">memcached -m 1 -u root -d -l 127.0.0.1 -p 11212</span><br></pre></td></tr></table></figure></p>
<p><strong>启动两个magent进程，端口分别为10000,10001</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">magent -u root -n 51200 -l 127.0.0.1 -p 10000 -s 127.0.0.1:11211 -b 127.0.0.1:11212</span><br><span class="line">magent -u root -n 51200 -l 127.0.0.1 -p 10001 -s 127.0.0.1:11212 -b 127.0.0.1 11211</span><br></pre></td></tr></table></figure></p>
<p>-s为要写入的memcached，-b为备份用的memcached    </p>
<p>#3、使用</p>
<p>##3.1、清空缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 11211</span><br><span class="line">flush_all</span><br><span class="line">quit</span><br></pre></td></tr></table></figure></p>
<p>#4、监控</p>
<p>##4.1、stats<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 11211</span><br><span class="line">stats</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>相关资源：</p>
<p><a href="http://www.cnblogs.com/happyday56/p/3461113.html" title="memcached+magent实现memcached集群" target="_blank" rel="external">memcached+magent实现memcached集群</a>     </p>
<p><a href="http://zhumeng8337797.blog.163.com/blog/static/10076891420113431424757/" title="memcache集群服务：memagent配置使用  " target="_blank" rel="external">memcache集群服务：memagent配置使用  </a></p>
<p>发表于：<a href="http://www.itzhai.com/mc-config-and-monitoring.html" target="_blank" rel="external">http://www.itzhai.com/mc-config-and-monitoring.html</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/Cache/">Cache</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/Memcached/">Memcached</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/design-pattern/20150209_设计模式笔记/"><span>设计模式笔记</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/design-pattern/20150209_设计模式笔记/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-11T09:40:14.000Z">
          2016-02-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>##职责链模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-01.png" alt=""> </p>
<p>###说明：<br>通过把对象链接起来，给更多的对象处理请求的机会。</p>
<p>###使用场景：</p>
<ul>
<li>多个对象需要处理一个请求，并且处理请求的对象不是特定的；</li>
<li>运行期才能决定哪些对象需要处理这个请求；</li>
<li>允许出现一个请求可能不被其中一个对象处理的情况；</li>
</ul>
<p>###实例：<br>Java语言的异常处理实现使用了职责链模式；</p>
<p>##命令模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-02.png" alt=""></p>
<p>###说明：<br>把一个请求封装成一个对象，让请求被当成基于对象的形式进行处理，如回调。</p>
<p>###使用场景：</p>
<ul>
<li>你需要回调函数的时候；</li>
<li>请求需要在不同的时间或者通过不同的顺序进行处理；</li>
<li>需要请求的历史记录；</li>
<li>调用者需要和执行者解耦的时候</li>
</ul>
<p>###实例：<br>任务队列</p>
<p>##解析器模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-03.png" alt="">  </p>
<p>###说明：<br>为文法提供一个解析的机制。</p>
<p>###使用场景：</p>
<ul>
<li>需要把文法解析成一个大的语法树；</li>
<li>文法比较简单；</li>
<li>解析的过程中性能并不是很重要；</li>
<li>需要把文法和解析式进行解耦；</li>
</ul>
<p>###实例<br>上个世纪80年代流行的基于文字的冒险游戏。</p>
<p>##迭代器模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-04.png" alt=""></p>
<p>###说明：<br>在不知道集合类实现的情况下，实现访问集合元素的功能。</p>
<p>###使用场景：</p>
<ul>
<li>不访问对象的情况下，需要访问到对象里面的元素</li>
<li>需要支持多线程或者并发遍历集合</li>
<li>需要一个同一个遍历接口</li>
<li>不同的迭代器实现由细微的差别</li>
</ul>
<p>###实例：<br>Java的集合类就很好的用到了迭代器模式，允许用户在不知道集合的实现的情况下遍历各种类型的数据集合。</p>
<p>##中介者模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-05.png" alt=""></p>
<p>###说明：<br>通过封装不同对象集的交互来达到解耦这些对象。</p>
<p>###使用场景：</p>
<ul>
<li>对象间的交流动作有明确的定义，并且很复杂；</li>
<li>对象间存在复杂的交互关系，并且需要一个中央的控制节点来转发这些交互。</li>
</ul>
<p>###实例：<br>邮件群发系统，通过中介者模式，发送者无需记录哪些邮件地址是否注册了，把邮件发给中介者，中介者把邮件转发给有效的接收者。</p>
<p>##备忘录模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-06.png" alt=""></p>
<p>###说明：<br>在不违反封装性的前提下，允许捕获并且外化一个对象的内部状态，以便存储下来。</p>
<p>###使用场景：</p>
<ul>
<li>一个对象的内部状态需要存储下来；</li>
<li>一个对象的内部状态没有提供对外暴露的接口；</li>
<li>封装的边界必须被保存</li>
</ul>
<p>###实例：<br>撤销动作，通过建立对象的一个快照实现。</p>
<p>##观察者模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-07.png" alt=""></p>
<p>###说明：<br>在一个系统中，当一个对象的状态改变的时候，通知其他对象。</p>
<p>###使用场景：</p>
<ul>
<li>一个或多个对象状态的改变触发其他对象的处理事件</li>
<li>需要广播的能力</li>
<li></li>
</ul>
<p>###实例：<br>在大部分的GUI环境中都有用到这个设计模式，通过把按钮，文本区等注册为观察者，当一个用户触发一个事件，就发送一个通知到所有的观察者。</p>
<p>##状态模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-08.png" alt=""></p>
<p>###说明：</p>
<p>###使用场景：</p>
<p>###实例：</p>
<p>##策略模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-09.png" alt=""></p>
<p>##模板模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-10.png" alt=""></p>
<p>##访问者模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-11.png" alt="">     </p>
<p>##适配器模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-12.png" alt="">    </p>
<p>##桥接模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-13.png" alt=""></p>
<p>##组合模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-14.png" alt=""></p>
<p>##装饰者模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-15.png" alt=""></p>
<p>##门面模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-16.png" alt=""></p>
<p>##享元模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-17.png" alt=""></p>
<p>##代理模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-18.png" alt=""></p>
<p>##抽象工厂模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-19.png" alt=""></p>
<p>##构建者模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-20.png" alt=""></p>
<p>##工厂方法模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-21.png" alt=""></p>
<p>##原型模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-22.png" alt=""></p>
<p>##单例模式<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2015/02/20150207-design-pattern-23.png" alt="">           </p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/设计模式/">设计模式</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/职责链模式/">职责链模式</a>, <a href="/tags/命令模式/">命令模式</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/Java/spring/2014122402-spring-beans/"><span>Spring beans</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/Java/spring/2014122402-spring-beans/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-11T09:40:14.000Z">
          2016-02-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>Bean 组件在 Spring 的 org.springframework.beans 包下。这个包下的所有类主要解决了三件事：Bean 的定义、Bean 的创建以及对 Bean 的解析。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。</p>
<p>Spring Bean 的创建是典型的工厂模式，他的顶级接口是 BeanFactory，下图是这个工厂的继承层次关系：    </p>
<p><strong>Bean工厂的继承关系</strong><br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2014/12/20141224-spring002.png" alt=""></p>
<p>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表的，而 HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。    </p>
<p><strong>Bean定义的类层次关系图</strong>    </p>
<p>Bean 的定义主要由 BeanDefinition 描述，如下图说明了这些类的层次关系：<br><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2014/12/20141224-spring003.png" alt=""><br>Bean 的定义就是完整的描述了在 Spring 的配置文件中你定义的 <bean> 节点中所有的信息，包括各种子节点。当 Spring 成功解析你定义的一个 <bean> 节点后，在 Spring 的内部他就被转化成 BeanDefinition 对象。以后所有的操作都是对这个对象完成的。</bean></bean></p>
<p>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过下图中的类完成：    </p>
<p><strong>Bean的解析类</strong></p>
<p><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2014/12/20141224-spring004.png" alt=""></p>
<p><a href="https://github.com/arthinking/java-code/blob/master/src/main/java/me/arthinking/spring/ioc/BeanFactoryTest.java" title="通过XmlBeanFactory实现启动Spring IoC容器" target="_blank" rel="external">通过XmlBeanFactory实现启动Spring IoC容器</a></p>
<blockquote>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/" title="Spring 框架的设计理念与设计模式分析" target="_blank" rel="external">Spring 框架的设计理念与设计模式分析</a> </p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/Java/">Java</a>, <a href="/categories/Java/Spring/">Spring</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/server/服务器监控/"><span>服务器监控</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/server/服务器监控/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-11T09:40:14.000Z">
          2016-02-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>#缓存<br><a href="https://github.com/arthinking/informal-essay/blob/master/memcached/Memcached%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%9B%91%E6%8E%A7.md" title="memcached的配置与监控" target="_blank" rel="external">memcached的配置与监控</a><br>通过查看占用内存，决定需不需要进行扩容</p>
<p>#JDK监控</p>
<p>#应用服务器监控</p>
<p>#数据库监控</p>
<p>##数据库内存监控</p>
<p>##数据库访问监控</p>
<p>##数据库并发测试</p>
<p>#nginx并发访问监控</p>
<p>#Lucene服务监控</p>
<p>##占用内存</p>
<p>##查询效率</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/监控/">监控</a>
  </span>


          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/IDE/20141204_配置Maven项目自动编译/"><span>配置Maven项目自动编译</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/IDE/20141204_配置Maven项目自动编译/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-11T09:40:14.000Z">
          2016-02-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<p>##Maven项目目录结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">    - src    </span><br><span class="line">        - main</span><br><span class="line">            - java</span><br><span class="line">            - resources</span><br><span class="line">            - webapp</span><br><span class="line">                - WEB-INF</span><br><span class="line">                    - classes</span><br><span class="line">                    - lib</span><br><span class="line">    - target</span><br><span class="line">        - project-snapshot</span><br><span class="line">            - WEB-INF</span><br><span class="line">                - classes</span><br><span class="line">                - lib</span><br><span class="line">        - classes</span><br><span class="line">```     </span><br><span class="line">其中 project-snapshot就是maven编译生成的项目目录了，我们一般使用这个目录对项目进行部署，这样问题来了：  </span><br><span class="line">  </span><br><span class="line">每次改动JSP文件或者Java文件，都得重新用maven编译一下，以便生成代码到该目录，有没有方便点的做法呢？接下来就是啦。</span><br><span class="line"></span><br><span class="line">##让Maven项目自动编译：    </span><br><span class="line">    </span><br><span class="line">为了让改写JSP之后无需重新编译，我们只有使用src/main/webapp/这个目录进行部署了，因为一般我们是直接改动里面的文件进行编码的；    </span><br><span class="line">    </span><br><span class="line">而jar包是maven从仓库下载过来的，为了能用上下载回来的jar包，我们可以把</span><br><span class="line">&gt; target/project-snapshot/WEB-INF/lib   </span><br><span class="line">  </span><br><span class="line">目录联接到</span><br><span class="line">    </span><br><span class="line">&gt; src/main/webapp/WEB-INF/lib</span><br><span class="line"></span><br><span class="line">windows下通过 [mklink /j](http://technet.microsoft.com/en-us/library/cc753194.aspx &quot;mklink&quot;) 命令(假设项目在D:/dev目录下)：</span><br></pre></td></tr></table></figure></p>
<p>mklink /j “D:\dev\project\src\main\webapp\WEB-INF\lib” “D:\dev\project\target\project-snapshot\WEB-INF\lib”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这样就把maven下载的lib目录联接到部署目录webapp下了；</span><br><span class="line">   </span><br><span class="line">对于class目录，也是同样的方法，另外需要设置IDE的自动编译输出目录到：</span><br><span class="line">&gt; target/project-snapshot/WEB-INF/classes    </span><br><span class="line"></span><br><span class="line">右击项目 -&gt; properties -&gt; Java Build Path -&gt; 右边面板底部设置Default output folder；        </span><br><span class="line"></span><br><span class="line">##直接运行main方法的问题</span><br><span class="line"></span><br><span class="line">但是这样Eclipse下会有个问题，直接运行某个类的main方法，会提示如下错误：</span><br></pre></td></tr></table></figure></p>
<p>java.lang.NoClassDefFoundError: me/arthinking/test/Demo<br>Caused by: java.lang.ClassNotFoundException: me.arthinking.test.Demo<br>    at java.net.URLClassLoader$1.run(URLClassLoader.java:202)<br>    at java.security.AccessController.doPrivileged(Native Method)<br>    at java.net.URLClassLoader.findClass(URLClassLoader.java:190)<br>    at java.lang.ClassLoader.loadClass(ClassLoader.java:306)<br>    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)<br>    at java.lang.ClassLoader.loadClass(ClassLoader.java:247)<br>Exception in thread “main”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">原因是没有读取到输出的classes文件，为此，我们可以把class编译输出目录设置为：    </span><br><span class="line"></span><br><span class="line">&gt; project/target/classes</span><br><span class="line"></span><br><span class="line">这样就可以正常执行main方法了</span><br><span class="line"></span><br><span class="line">把这个目录联接到webapp/WEB-INF/classes目录下即可。</span><br><span class="line">编译目录设置如图：    </span><br><span class="line">![](https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2014/12/20141204-java01.png)</span><br><span class="line"></span><br><span class="line">其他的配置文件目录需要联接到webapp目录，同上操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##关于IDEA集成开发环境</span><br><span class="line"></span><br><span class="line">据[Ryan](https://github.com/mojunbin &quot;Ryan&quot;)介绍，IDEA集成开发环境是不会存在找不到main方法的问题的；</span><br><span class="line"></span><br><span class="line">另外我们也可以在pom.xml中配置classes文件的输出目录，把classes文件输出到webapp目录下，这样改写了Java文件之后需要使用maven编译下项目了。:sunglasses:     </span><br><span class="line">pom.xml</span><br><span class="line">```xml</span><br><span class="line">&lt;outputDirectory&gt;D:\dev\project\webapp\WEB-INF\classes&lt;/outputDirectory&gt;</span><br></pre></td></tr></table></figure></p>
<p>##Resin中的配置<br>现在我用着Resin，恰巧，resin里面提供了一个 <a href="http://www.caucho.com/resin-4.0/reference.xtp#classloader" title="&lt;class-loader&gt;" target="_blank" rel="external"><class-loader></class-loader></a> 的配置标签，通过其中的 <a href="http://www.caucho.com/resin-4.0/reference.xtp#compilingloader" title="[&lt;compiling-loader&gt;]" target="_blank" rel="external"><compiling-loader></compiling-loader></a> 和 <a href="http://www.caucho.com/resin-4.0/reference.xtp#libraryloader" title="&lt;library-loader&gt;" target="_blank" rel="external"><library-loader></library-loader></a> 子标签同样可以配置加载class文件和jar包的位置，配置代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">id</span>=<span class="string">"/"</span> <span class="attr">root-directory</span>=<span class="string">"D:\dev\project\src\main\webapp"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">prologue</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">class-loader</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">compiling-loader</span> <span class="attr">path</span>=<span class="string">"D:\dev\project\target\classes"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">library-loader</span> <span class="attr">path</span>=<span class="string">"D:\dev\project\target\project-snapshot\WEB-INF\lib"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">class-loader</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">prologue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>进一步查看<a href="http://caucho.com/resin-4.0/reference.xtp#compilingloader" title="官方文档" target="_blank" rel="external">官方文档</a>可以发现有这样的介绍：</p>
<blockquote>
<p>automatically compiles Java code into .class files before loading them.    </p>
</blockquote>
<p>首先这里class-loader实现了热部署（类似的一般的Servlet容器都提供了JSP的加载器，如Tomcat的<a href="http://my.oschina.net/heroShane/blog/198450" title="JasperLoader" target="_blank" rel="external">JasperLoader</a>，当容器检测到JSP文件被修改的时候，会自动替换掉原来的JSP加载器的Class实例，并创建一个新的，从而实现热部署。关于Resin中的<a href="http://coolshell.cn/articles/6112.html" title="类加载器执行问题" target="_blank" rel="external">类加载器执行问题</a>），那么如果会在加载class文件之前重新编译源代码，就需要提供源代码的目录，查看文档，可以发现source这样的一个属性，添加上之后配置如下：    </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">compiling-loader</span> <span class="attr">path</span>=<span class="string">"D:\dev\project\target\classes"</span> <span class="attr">source</span>=<span class="string">"D:\dev\project\src\main\java"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就会在加载class前先自动编译Java代码了，这对于Eclipse没有开启自动编译功能的环境尤其有用（Eclipse的自动编译功能也是需要一定的资源开销的，有时候会导致Eclipse卡住，如果关闭了该功能，可以尝试以上配置）。</p>
<p>##其他的热部署方案</p>
<p>###热部署神器<a href="http://zeroturnaround.com/software/jrebel/" title="JRebel" target="_blank" rel="external">JRebel</a>    </p>
<p><a href="http://zeroturnaround.com/software/jrebel/features/comparison-matrix/" title="这里" target="_blank" rel="external">这里</a>是JRebel和JVM Hot Swap的区别</p>
<p>另外，<a href="http://jm-blog.aliapp.com/?p=641" title="这里" target="_blank" rel="external">这里</a>有一个JVM hotswap的补丁</p>
<blockquote>
<p>说到HotSwap特性，是在2002年的时候，Sun在Java 1.4的JVM中引入的实验性技术。这一技术被合成到了DebuggerAPI的内部。<br><a href="http://article.yeeyan.org/view/213582/186226" title="HotSwap和JRebel——幕后的故事" target="_blank" rel="external">《HotSwap和JRebel——幕后的故事》</a></p>
</blockquote>
<p>###Resin中的热部署<br>在resin.conf中添加如下的JVM启动参数：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jvm-arg</span>&gt;</span>-Xdebug<span class="tag">&lt;/<span class="name">jvm-arg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>表示启动debug模式，当更新了类中的方法的时候，控制台会提示reloading class，这是通过JVM的HotSwap功能动态更新的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... Reloading ...</span><br></pre></td></tr></table></figure>
<p>由于JVM的HotSwap不支持新增属性，方法和类的修改，所以进行了这些操作之后，是无法实现热部署的，Resin会自动改用Hot deploy的方式进行应用更新。</p>
<p>当去掉该启动参数的时候，修改一个类，控制台会提示如下的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... WebApp[...] stopping</span><br><span class="line">... WebApp[...] active</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发表于：<a href="http://www.itzhai.com/maven-setting-auto-compile.html" target="_blank" rel="external">http://www.itzhai.com/maven-setting-auto-compile.html</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/构建/">构建</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/Maven/">Maven</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/operating-system/mac/2016-02-11 Mac下相关快捷键/"><span>Mac实用快捷键</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/operating-system/mac/2016-02-11 Mac下相关快捷键/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-11T09:10:44.000Z">
          2016-02-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>Author: ChinSyun Pang<br>Weibo: <a href="http://weibo.com/arthinkingplus" target="_blank" rel="external">arthinking_plus</a><br>Posted in: <a href="http://www.itzhai.com" target="_blank" rel="external">http://www.itzhai.com</a></p>
</blockquote>
<h1 id="Mac下相关快捷键"><a href="#Mac下相关快捷键" class="headerlink" title="Mac下相关快捷键"></a>Mac下相关快捷键</h1><p><img src="https://raw.githubusercontent.com/arthinking/informal-essay/master/images/2016/02/20160212-mac-shotcut-01.png" alt=""></p>
<p><a href="https://www.zhihu.com/question/20021861" target="_blank" rel="external">常用快捷键</a></p>
<p><a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="external">官方快捷键说明</a></p>
<p>Mac 菜单和键盘通常使用某些按键的符号，其中包括以下修饰键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Command ⌘</span><br><span class="line">Shift ⇧</span><br><span class="line">Option ⌥</span><br><span class="line">Control ⌃</span><br><span class="line">Caps Lock ⇪</span><br><span class="line">Fn</span><br></pre></td></tr></table></figure></p>
<h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>快速切换中英文：<code>caps lock</code>，按了之后<code>caps lock</code>键会亮起绿灯。</p>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><ul>
<li>command＋shift＋3是全屏截图</li>
<li>command＋shift＋4是局部截图</li>
</ul>
<p>图片默认存储在桌面。</p>
<h4 id="设置截图保存路径"><a href="#设置截图保存路径" class="headerlink" title="设置截图保存路径"></a>设置截图保存路径</h4><p>打开<code>Terminal</code>并输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.screencapture location /path/</span><br></pre></td></tr></table></figure></p>
<p>/path/即你想要设置的保存路径，比如将截图文件存储在用户目录的图片（Pictures）文件夹，命令则为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.screencapture location ~/Pictures/</span><br></pre></td></tr></table></figure></p>
<p>接下来，为了使得修改生效，输入下面这条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall SystemUIServer</span><br></pre></td></tr></table></figure></p>
<p>当然，如果你习惯将截图保存在桌面的话，/path/ 对应的路径为 ~/Desktop/。</p>
<h4 id="设置截图文件格式"><a href="#设置截图文件格式" class="headerlink" title="设置截图文件格式"></a>设置截图文件格式</h4><p>OS X 系统默认截图文件格式为 png，通过下面的终端（Terminal）命令可以修改截图文件格式为 jpg ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.screencapture type jpg</span><br></pre></td></tr></table></figure></p>
<p>另外，还可以将命令中的 jpg 修改为 gif 或 pdf，以及改回默认的 png 格式。同样别忘了输入上面那条使得修改生效的命令。</p>
<p>⌘ t: 新建一个tab页</p>
<p>⌘ shift []: 切换tab页</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
  

  <span class="post-categories">
    <i class="icon-categories"></i>
    <a href="/categories/Mac/">Mac</a>
  </span>


          
  

  <span class="post-tags">
    <i class="icon-tags"></i>
    <a href="/tags/快捷键/">快捷键</a>
  </span>


        </div>
        
    </footer>
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/4/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/6/" class="pagination-next">Next</a>
  
</nav>
      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 arthinking
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>