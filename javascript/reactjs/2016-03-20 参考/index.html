<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>arthinking | ChinSyun Pang&#39;s blog</title>
  <meta name="author" content="arthinking">
  
  <meta name="description" content="Struggle for HighPay zoom.">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:site_name" content="arthinking"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="arthinking" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">arthinking</a>
  </h1>
  <p class="site-description">ChinSyun Pang&#39;s blog</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        <article class="post article">

  
  
    <h3 class="article-title"><span></span></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/javascript/reactjs/2016-03-20 参考/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-20T07:07:56.000Z">
          2016-03-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="1、顶层API"><a href="#1、顶层API" class="headerlink" title="1、顶层API"></a>1、顶层API</h1><h2 id="1-1、React"><a href="#1-1、React" class="headerlink" title="1.1、React"></a>1.1、React</h2><p>React 是 React 库的入口。如果使用的是预编译包，则 React 是全局的；如果使用 CommonJS 模块系统，则可以用 require() 函数引入 React。</p>
<h3 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass"></a>React.createClass</h3><p>创建一个组件类，并作出定义。组件实现了 render() 方法，该方法返回一个子级。该子级可能包含很深的子级结构。</p>
<h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h3><p>创建并返回一个新的指定类型的 ReactElement。</p>
<h3 id="React-createFactory"><a href="#React-createFactory" class="headerlink" title="React.createFactory"></a>React.createFactory</h3><p>返回一个生成指定类型 ReactElements 的函数。</p>
<h3 id="React-render"><a href="#React-render" class="headerlink" title="React.render"></a>React.render</h3><p>渲染一个 ReactElement 到 DOM 中。</p>
<h3 id="React-unmountComponentAtNode"><a href="#React-unmountComponentAtNode" class="headerlink" title="React.unmountComponentAtNode"></a>React.unmountComponentAtNode</h3><p>从 DOM 中移除已经挂载的 React 组件，清除相应的事件处理器和 state。</p>
<h3 id="React-renderToString"><a href="#React-renderToString" class="headerlink" title="React.renderToString"></a>React.renderToString</h3><p>把组件渲染成原始的 HTML 字符串。该方法应该仅在服务器端使用。</p>
<h3 id="React-renderToStaticMarkup"><a href="#React-renderToStaticMarkup" class="headerlink" title="React.renderToStaticMarkup"></a>React.renderToStaticMarkup</h3><p>和 renderToString 类似，除了不创建额外的 DOM 属性，例如 data-react-id，因为这些属性仅在 React 内部使用。如果你想用 React 做一个简单的静态页面生成器，这是很有用的，因为丢掉额外的属性能够节省很多字节。</p>
<h3 id="React-isValidElement"><a href="#React-isValidElement" class="headerlink" title="React.isValidElement"></a>React.isValidElement</h3><p>判断对象是否是一个 ReactElement。</p>
<h3 id="React-DOM"><a href="#React-DOM" class="headerlink" title="React.DOM"></a>React.DOM</h3><p>React.DOM 运用 React.createElement 为 DOM 组件提供了方便的包装。该方式仅在未使用 JSX 的时候适用。例如，React.DOM.div(null, ‘Hello World!’)。</p>
<h3 id="React-PropTypes"><a href="#React-PropTypes" class="headerlink" title="React.PropTypes"></a>React.PropTypes</h3><p>React.PropTypes 包含了能与组件 propTypes 对象共用的类型，用于验证传入组件的 props。</p>
<h3 id="React-initializeTouchEvents"><a href="#React-initializeTouchEvents" class="headerlink" title="React.initializeTouchEvents"></a>React.initializeTouchEvents</h3><p>配置 React 的事件系统，使 React 能处理移动设备的触摸（ touch ）事件。</p>
<h3 id="React-Children"><a href="#React-Children" class="headerlink" title="React.Children"></a>React.Children</h3><p>React.Children 为处理 this.props.children 这个封闭的数据结构提供了有用的工具。</p>
<h4 id="React-Children-map"><a href="#React-Children-map" class="headerlink" title="React.Children.map"></a>React.Children.map</h4><p>在每一个直接子级（包含在 children 参数中的）上调用 fn 函数，此函数中的 this 指向 上下文。如果 children 是一个内嵌的对象或者数组，它将被遍历：不会传入容器对象到 fn 中。</p>
<h4 id="React-Children-forEach"><a href="#React-Children-forEach" class="headerlink" title="React.Children.forEach"></a>React.Children.forEach</h4><p>类似于 React.Children.map()，但是不返回对象。</p>
<h4 id="React-Children-count"><a href="#React-Children-count" class="headerlink" title="React.Children.count"></a>React.Children.count</h4><p>返回 children 当中的组件总数，和传递给 map 或者 forEach 的回调函数的调用次数一致。</p>
<h4 id="React-Children-only"><a href="#React-Children-only" class="headerlink" title="React.Children.only"></a>React.Children.only</h4><p>返回 children 中仅有的子级。否则抛出异常。</p>
<h1 id="2、组件API"><a href="#2、组件API" class="headerlink" title="2、组件API"></a>2、组件API</h1><p>ReactComponent。唯一一种在 React 之外获取 React 组件实例句柄的方式就是保存 React.render 的返回值。在其它组件内，可以使用 refs 得到相同的结果。</p>
<h2 id="2-1、setState"><a href="#2-1、setState" class="headerlink" title="2.1、setState"></a>2.1、setState</h2><p>合并 nextState 和当前 state。这是在事件处理函数中和请求回调函数中触发 UI 更新的主要方法。</p>
<blockquote>
<p>绝对不要直接改变 this.state；<br>setState() 不会立刻改变 this.state，而是创建一个即将处理的 state 转变；<br>不保证 setState() 调用的同步性；<br>setState() 将总是触发一次重绘，除非在 shouldComponentUpdate() 中实现了条件渲染逻辑。</p>
</blockquote>
<h2 id="2-2、replaceState"><a href="#2-2、replaceState" class="headerlink" title="2.2、replaceState"></a>2.2、replaceState</h2><p>类似于 setState()，但是删除之前所有已存在的 state 键，这些键都不在 nextState 中。</p>
<h2 id="2-3、forceUpdate"><a href="#2-3、forceUpdate" class="headerlink" title="2.3、forceUpdate()"></a>2.3、forceUpdate()</h2><p>如果 render() 方法从 this.props 或者 this.state 之外的地方读取数据，你需要通过调用 forceUpdate() 告诉 React 什么时候需要再次运行 render()。如果直接改变了 this.state，也需要调用 forceUpdate()。</p>
<p>通常情况下，应该尽量避免所有使用forceUpdate()的情况。</p>
<h2 id="2-4、getDOMNode"><a href="#2-4、getDOMNode" class="headerlink" title="2.4、getDOMNode"></a>2.4、getDOMNode</h2><p>如果组件已经挂载到了 DOM 上，该方法返回相应的本地浏览器 DOM 元素。</p>
<h2 id="2-5、iSMounted"><a href="#2-5、iSMounted" class="headerlink" title="2.5、iSMounted()"></a>2.5、iSMounted()</h2><p>如果组件渲染到了 DOM 中，isMounted() 返回 true。</p>
<h2 id="2-6、setProps"><a href="#2-6、setProps" class="headerlink" title="2.6、setProps()"></a>2.6、setProps()</h2><p>可以调用 setProps() 来改变组件的属性，触发一次重新渲染。</p>
<blockquote>
<p>刚方法仅在根组件上面调用。也就是说，仅在直接传给 React.render() 的组件上可用，在它的子级组件上不可用。如果你倾向于在子组件上使用 setProps()，不要利用响应式更新，而是当子组件在 render() 中创建的时候传入新的 prop 到子组件中。</p>
</blockquote>
<h2 id="2-7、replaceProps"><a href="#2-7、replaceProps" class="headerlink" title="2.7、replaceProps"></a>2.7、replaceProps</h2><p>类似于 setProps()，但是删除所有已存在的 props，而不是合并新旧两个 props 对象。</p>
<h1 id="3、组件的详细说明和生命周期"><a href="#3、组件的详细说明和生命周期" class="headerlink" title="3、组件的详细说明和生命周期"></a>3、组件的详细说明和生命周期</h1><h2 id="3-1、组件的详细说明"><a href="#3-1、组件的详细说明" class="headerlink" title="3.1、组件的详细说明"></a>3.1、组件的详细说明</h2><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>当调用的时候，会检测 this.props 和 this.state，返回一个单子级组件。</p>
<p>render() 函数应该是纯粹的，也就是说该函数不修改组件 state，每次调用都返回相同的结果，不读写 DOM 信息，也不和浏览器交互（例如通过使用 setTimeout）。</p>
<h3 id="getInitialState"><a href="#getInitialState" class="headerlink" title="getInitialState"></a>getInitialState</h3><p>在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。</p>
<h3 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h3><p>在组件类创建的时候调用一次，然后返回值被缓存下来。如果父组件没有指定 props 中的某个键，则此处返回的对象中的相应属性将会合并到 this.props （使用 in 检测属性）。</p>
<h3 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h3><p>propTypes 对象允许验证传入到组件的 props。</p>
<h3 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h3><p>mixin 数组允许使用混合来在多个组件之间共享行为。</p>
<h3 id="statics"><a href="#statics" class="headerlink" title="statics"></a>statics</h3><p>statics 对象允许你定义静态的方法，这些静态的方法可以在组件类上调用。</p>
<h3 id="displayName"><a href="#displayName" class="headerlink" title="displayName"></a>displayName</h3><p>displayName 字符串用于输出调试信息。</p>
<h2 id="3-2、组件的生命周期"><a href="#3-2、组件的生命周期" class="headerlink" title="3.2、组件的生命周期"></a>3.2、组件的生命周期</h2><h3 id="挂载：componentWillMount"><a href="#挂载：componentWillMount" class="headerlink" title="挂载：componentWillMount"></a>挂载：componentWillMount</h3><p>服务器端和客户端都只调用一次，在初始化渲染执行之前立刻调用。如果在这个方法内调用 setState，render() 将会感知到更新后的 state，将会执行仅一次，尽管 state 改变了。</p>
<h3 id="挂载：componentDidMount"><a href="#挂载：componentDidMount" class="headerlink" title="挂载：componentDidMount"></a>挂载：componentDidMount</h3><p>在初始化渲染执行之后立刻调用一次，仅客户端有效（服务器端不会调用）。在生命周期中的这个时间点，组件拥有一个 DOM 展现，你可以通过 this.getDOMNode() 来获取相应 DOM 节点。</p>
<p>如果想和其它 JavaScript 框架集成，使用 setTimeout 或者 setInterval 来设置定时器，或者发送 AJAX 请求，可以在该方法中执行这些操作。</p>
<h3 id="更新：componentWillReceiveProps"><a href="#更新：componentWillReceiveProps" class="headerlink" title="更新：componentWillReceiveProps"></a>更新：componentWillReceiveProps</h3><p>在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。</p>
<p>用此函数可以作为 react 在 prop 传入之后， render() 渲染之前更新 state 的机会。老的 props 可以通过 this.props 获取到。在该函数中调用 this.setState() 将不会引起第二次渲染。</p>
<h3 id="更新：shouldComponentUpdate"><a href="#更新：shouldComponentUpdate" class="headerlink" title="更新：shouldComponentUpdate"></a>更新：shouldComponentUpdate</h3><p>在接收到新的 props 或者 state，将要渲染之前调用。该方法在初始化渲染的时候不会调用，在使用 forceUpdate 方法的时候也不会。</p>
<p>如果确定新的 props 和 state 不会导致组件更新，则此处应该 返回 false。</p>
<h3 id="更新：componentWillUpdate"><a href="#更新：componentWillUpdate" class="headerlink" title="更新：componentWillUpdate"></a>更新：componentWillUpdate</h3><p>在接收到新的 props 或者 state 之前立刻调用。在初始化渲染的时候该方法不会被调用。</p>
<p>使用该方法做一些更新之前的准备工作。</p>
<blockquote>
<p>你不能在刚方法中使用 this.setState()。如果需要更新 state 来响应某个 prop 的改变，请使用 componentWillReceiveProps。</p>
</blockquote>
<h3 id="更新：componentDidUpdate"><a href="#更新：componentDidUpdate" class="headerlink" title="更新：componentDidUpdate"></a>更新：componentDidUpdate</h3><p>在组件的更新已经同步到 DOM 中之后立刻被调用。该方法不会在初始化渲染的时候调用。</p>
<p>使用该方法可以在组件更新之后操作 DOM 元素。</p>
<h3 id="移除：componentWillUnmount"><a href="#移除：componentWillUnmount" class="headerlink" title="移除：componentWillUnmount"></a>移除：componentWillUnmount</h3><p>在组件从 DOM 中移除的时候立刻被调用。</p>
<p>在该方法中执行任何必要的清理，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素。</p>
<h1 id="3、标签和属性支持"><a href="#3、标签和属性支持" class="headerlink" title="3、标签和属性支持"></a>3、标签和属性支持</h1><h2 id="3-1、支持的标签"><a href="#3-1、支持的标签" class="headerlink" title="3.1、支持的标签"></a>3.1、支持的标签</h2><p>React 尝试支持所用常用的元素。如果你需要的元素没有在下面列出来，请提交一个问题（issue）。</p>
<h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><h3 id="SVG元素"><a href="#SVG元素" class="headerlink" title="SVG元素"></a>SVG元素</h3><h2 id="3-2、支持度-属性"><a href="#3-2、支持度-属性" class="headerlink" title="3.2、支持度 属性"></a>3.2、支持度 属性</h2><p>React 支持所有 data-<em> 和 aria-</em> 属性，也支持下面列出的属性。</p>
<blockquote>
<p>所有的属性都是驼峰命名的，class 属性和 for 属性分别改为 className 和 htmlFor，来符合 DOM API 规范。</p>
</blockquote>
<h3 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept acceptCharset accessKey action allowFullScreen allowTransparency altasync autoComplete autoPlay cellPadding cellSpacing charSet checked classIDclassName cols colSpan content contentEditable contextMenu controls coordscrossOrigin data dateTime defer dir disabled download draggable encType formformAction formEncType formMethod formNoValidate formTarget frameBorder heighthidden href hrefLang htmlFor httpEquiv icon id label lang list loop manifestmarginHeight marginWidth max maxLength media mediaGroup method min multiplemuted name noValidate open pattern placeholder poster preload radioGroupreadOnly rel required role rows rowSpan sandbox scope scrolling seamlessselected shape size sizes span spellCheck src srcDoc srcSet start step styletabIndex target title type useMap value width wmode</span><br></pre></td></tr></table></figure>
<h3 id="SVG属性"><a href="#SVG属性" class="headerlink" title="SVG属性"></a>SVG属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx cy d dx dy fill fillOpacity fontFamily fontSize fx fy gradientTransformgradientUnits markerEnd markerMid markerStart offset opacitypatternContentUnits patternUnits points preserveAspectRatio r rx ryspreadMethod stopColor stopOpacity stroke strokeDasharray strokeLinecapstrokeOpacity strokeWidth textAnchor transform version viewBox x1 x2 x y1 y2 y</span><br></pre></td></tr></table></figure>
<h1 id="4、事件系统"><a href="#4、事件系统" class="headerlink" title="4、事件系统"></a>4、事件系统</h1><h2 id="4-1、虚拟事件对象"><a href="#4-1、虚拟事件对象" class="headerlink" title="4.1、虚拟事件对象"></a>4.1、虚拟事件对象</h2><p>事件处理器将会传入虚拟事件对象的实例，一个对浏览器本地事件的跨浏览器封装。它有和浏览器本地事件相同的属性和方法，包括 stopPropagation() 和 preventDefault()，但是没有浏览器兼容问题。</p>
<p>如果因为一些因素，需要底层的浏览器事件对象，只要使用<code>nativeEvent</code>属性就可以获取到它了。每一个虚拟事件对象都有下列的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEvent<span class="keyword">void</span> preventDefault()<span class="keyword">void</span> stopPropagation()DOMEventTarget targetnumber timeStampstring type</span><br></pre></td></tr></table></figure>
<h2 id="4-2、支持的事件"><a href="#4-2、支持的事件" class="headerlink" title="4.2、支持的事件"></a>4.2、支持的事件</h2><p>React 标准化了事件对象，因此在不同的浏览器中都会有相同的属性。</p>
<p>如下的事件处理器在事件冒泡阶段触发。要在捕获阶段触发某个事件处理器，在事件名字后面追加 <code>Capture</code>字符串；例如，使用 onClickCapture </p>
<h3 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h3><blockquote>
<p>onCopy onCut onPaste</p>
</blockquote>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><blockquote>
<p>onKeyDown onKeyPress onKeyUp</p>
</blockquote>
<h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><blockquote>
<p>onFocus onBlur</p>
</blockquote>
<h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><blockquote>
<p>onChange onInput onSubmit</p>
</blockquote>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><blockquote>
<p>onClick onDoubleClick onDrag onDragEnd onDragEnter onDragExit onDragLeave<br>onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave<br>onMouseMove onMouseOut onMouseOver onMouseUp</p>
</blockquote>
<h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><blockquote>
<p>onTouchCancel onTouchEnd onTouchMove onTouchStart</p>
</blockquote>
<h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><blockquote>
<p>onScroll</p>
</blockquote>
<h3 id="鼠标滚轮滚动事件"><a href="#鼠标滚轮滚动事件" class="headerlink" title="鼠标滚轮滚动事件"></a>鼠标滚轮滚动事件</h3><blockquote>
<p>onWheel</p>
</blockquote>
<h1 id="5、与DOM的差异"><a href="#5、与DOM的差异" class="headerlink" title="5、与DOM的差异"></a>5、与DOM的差异</h1><p>React 为了性能和跨浏览器的原因，实现了一个独立于浏览器的事件和 DOM 系统。利用此功能，可以屏蔽掉一些浏览器的 DOM 的粗糙实现。</p>
<h1 id="6、特殊的非DOM属性"><a href="#6、特殊的非DOM属性" class="headerlink" title="6、特殊的非DOM属性"></a>6、特殊的非DOM属性</h1><p>除了与 DOM 的差异之外，React 也提供了一些 DOM 里面不存在的属性：</p>
<ul>
<li>key</li>
<li>ref</li>
<li>dangerouslySetInnerHTML</li>
</ul>
<h1 id="7、Reconciliation"><a href="#7、Reconciliation" class="headerlink" title="7、Reconciliation"></a>7、Reconciliation</h1><p>这篇文章解释了我们如何使用强大的试探法来将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题。</p>
<h2 id="7-1、动机"><a href="#7-1、动机" class="headerlink" title="7.1、动机"></a>7.1、动机</h2><p>生成最少的将一颗树形结构转换成另一颗树形结构的操作，是一个复杂的，并且值得研究的问题。最优算法的复杂度是 O(n3)，n 是树中节点的总数。</p>
<h2 id="7-2、两个节点的差异检查"><a href="#7-2、两个节点的差异检查" class="headerlink" title="7.2、两个节点的差异检查"></a>7.2、两个节点的差异检查</h2><h3 id="不同的节点类型"><a href="#不同的节点类型" class="headerlink" title="不同的节点类型"></a>不同的节点类型</h3><p>如果节点的类型不同，React 将会把它们当做两个不同的子树，移除之前的那棵子树，然后创建并插入第二棵子树。</p>
<h3 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h3><p>当比较两个 DOM 节点的时候，我们查看两者的属性，然后能够找出哪一个属性随着时间产生了变化。</p>
<h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><p>因为组件是状态化的，不可能每次状态改变都要创建一个新的组件实例。React 利用新组件上的所有属性，然后在之前的组件实例上调用 component[Will/Did]ReceiveProps()。</p>
<h2 id="7-2、子级优化差异算法（List-wise-diff）"><a href="#7-2、子级优化差异算法（List-wise-diff）" class="headerlink" title="7.2、子级优化差异算法（List-wise diff）"></a>7.2、子级优化差异算法（List-wise diff）</h2><h3 id="问题点（Problematic-Case）"><a href="#问题点（Problematic-Case）" class="headerlink" title="问题点（Problematic Case）"></a>问题点（Problematic Case）</h3><p>为了完成子级更新，React 选用了一种很原始的方法。React 同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。</p>
<h3 id="键（Keys）"><a href="#键（Keys）" class="headerlink" title="键（Keys）"></a>键（Keys）</h3><p>为了解决这个看起来很棘手的问题，引入了一个可选的属性。可以给每个子级一个键值，用于将来的匹配比较。如果指定了一个键值，React 就能够检测出节点插入、移除和替换，并且借助哈希表使节点移动复杂度为 O(n)。</p>
<h2 id="7-3、权衡（Trade-offs）"><a href="#7-3、权衡（Trade-offs）" class="headerlink" title="7.3、权衡（Trade-offs）"></a>7.3、权衡（Trade-offs）</h2><p>为了完成子级更新，React 选用了一种很原始的方法。React 同时遍历两个子级列表，当发现差异的时候，就产生一次 DOM 修改。</p>
<h1 id="8、React（虚拟）DOM术语"><a href="#8、React（虚拟）DOM术语" class="headerlink" title="8、React（虚拟）DOM术语"></a>8、React（虚拟）DOM术语</h1><p>五个核心类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactElement / ReactElement 工厂</span><br><span class="line">ReactNode</span><br><span class="line">ReactComponent / ReactComponent 类</span><br></pre></td></tr></table></figure>
<h2 id="8-1、React元素"><a href="#8-1、React元素" class="headerlink" title="8.1、React元素"></a>8.1、React元素</h2><p>React 中最主要的类型就是 ReactElement。它有四个属性：type，props，key 和 ref。它没有方法，并且原型上什么都没有。</p>
<p>可以通过 React.createElement 创建该类型的一个实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> root = React.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure>
<p>要添加属性到 DOM 元素，把属性对象作为第二个参数传入 React.render，把子级作为第三个参数传给 React.render。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = React.createElement(<span class="string">'li'</span>, <span class="literal">null</span>, <span class="string">'Text Content'</span>);</span><br><span class="line"><span class="keyword">var</span> root = React.createElement(<span class="string">'ul'</span>, &#123; className: <span class="string">'my-list'</span> &#125;, child);</span><br><span class="line">React.render(root, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p>如果使用 React JSX 语法，这些 ReactElement 实例自动创建。</p>
<h3 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h3><p>一个 ReactElement 工厂就是一个简单的函数，该函数生成一个带有特殊 type 属性的 ReactElement:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFactory</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement.bind(<span class="literal">null</span>, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数能创建一个方便的短函数，而不是总调用 React.createElement(‘div’):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = React.createFactory(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> root = div(&#123; className: <span class="string">'my-div'</span> &#125;);</span><br><span class="line">React.render(root, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p>React 已经内置了常用 HTML 标签的工厂函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> root = React.DOM.ul(&#123; className: <span class="string">'my-list'</span> &#125;,</span><br><span class="line">             React.DOM.li(<span class="literal">null</span>, <span class="string">'Text Content'</span>)</span><br><span class="line">           );</span><br></pre></td></tr></table></figure>
<p>如果使用 JSX 语法，就不需要工厂函数了。JSX 已经提供了一种方便的短函数来创建 ReactElement 实例。</p>
<h2 id="8-2、React节点"><a href="#8-2、React节点" class="headerlink" title="8.2、React节点"></a>8.2、React节点</h2><p>一个 ReactNode 可以是：</p>
<ul>
<li>ReactElement</li>
<li>string （又名 ReactText）</li>
<li>number （又名 ReactText）</li>
<li>ReactNode 实例数组 （又名 ReactFragment）</li>
</ul>
<h2 id="8-3、React组件"><a href="#8-3、React组件" class="headerlink" title="8.3、React组件"></a>8.3、React组件</h2><p>在使用 React 开发中，可以仅使用 ReactElement 实例，但是，要充分利用 React，就要使用 ReactComponent 来封装状态化的组件。</p>
<p>一个 ReactComponent 类就是一个简单的 JavaScript 类（或者说是“构造函数”）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当该构造函数调用的时候，应该会返回一个对象，该对象至少带有一个 render 方法。该对象指向一个 ReactComponent 实例。</p>
<p>除非为了测试，正常情况下不要自己调用该构造函数。React 帮你调用这个函数。</p>
<p>把 ReactComponent 类传给 createElement，就会得到一个 ReactElement 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = React.createElement(MyComponent);</span><br></pre></td></tr></table></figure>
<p>或者使用 JSX：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>当该实例传给 React.render 的时候，React 将会调用构造函数，然后创建并返回一个 ReactComponent。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> component = React.render(element, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p>如果一直用相同的 ReactElement 类型和相同的 DOM 元素容器调用 React.render，将会总是返回相同的实例。该实例是状态化的。如果自己手动创建Componnet实力，则不会又这样的优化。</p>
<p>ReactComponent 的 render 方法应该返回另一个 ReactElement，这就允许组件被组装。</p>
<h2 id="8-4、正式的类型定义"><a href="#8-4、正式的类型定义" class="headerlink" title="8.4、正式的类型定义"></a>8.4、正式的类型定义</h2><h3 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h3><h3 id="节点和元素"><a href="#节点和元素" class="headerlink" title="节点和元素"></a>节点和元素</h3><h3 id="类和组件"><a href="#类和组件" class="headerlink" title="类和组件"></a>类和组件</h3>
      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>

  



      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 arthinking
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>